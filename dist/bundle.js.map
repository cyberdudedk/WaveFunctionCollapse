{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;;;;;;;;;;;;;;;;ACNxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACTO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;;;;;;;;;;;;;;;;ACRxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACfO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACLwD;AAChB;AACA;AACF;AAC/B;AACP;AACA,0BAA0B,iDAAS;AACnC,uBAAuB,+CAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAAQ;AAC/B;AACA,6BAA6B,iDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8EAAQ,IAAoB,0BAA0B,OAAO,CAAC;AACvF;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,yEAAyB;AACrF;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,iEAAiE,4EAA4B;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,iEAAiE,sEAAsB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,iEAAiE,sEAAsB;AACvF;AACA;AACA,iEAAiE,+EAA+B;AAChG;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,iEAAiE,2EAA2B;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClOO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAA+C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAkD;AAC/E;AACA;AACA,6BAA6B,oDAAoD;AACjF;AACA;AACA,6BAA6B,qDAAqD;AAClF;AACA;AACA,6BAA6B,mDAAmD;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC9MwC;AACI;AACJ;AACJ;AAC7B;AACP;AACA,2BAA2B,6CAAO;AAClC,0BAA0B,iDAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6CAAO;AAClC;AACA;AACA;AACA;AACA;AACA,4CAA4C,6EAAQ,IAAmB,UAAU,OAAO,CAAC;AACzF,0CAA0C,4EAAQ,IAAkB,UAAU,OAAO,CAAC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAS;AACrC;AACA;AACA,uDAAuD,iDAAS;AAChE,yCAAyC,iDAAS;AAClD;AACA;AACA,+CAA+C,iDAAS;AACxD;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,6CAA6C,iDAAS;AACtD,2DAA2D,iDAAS;AACpE;AACA,mDAAmD,iDAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,iDAAS;AACjE,2DAA2D,iDAAS;AACpE;AACA,mDAAmD,iDAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iDAAS;AAC3C,2DAA2D,iDAAS;AACpE;AACA,+BAA+B,iDAAS;AACxC,qBAAqB;AACrB;AACA,2CAA2C,qDAAW;AACtD,aAAa;AACb;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gCAAgC;AAClE,gCAAgC,iCAAiC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;;;;;;;;;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UC5BA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;ACNsC;AACE;AACxC;AACA,eAAe,iDAAS;AACxB;AACA;AACA,eAAe,+CAAQ;AACvB","sources":["webpack://wavefunctioncollapse/./src/Direction.ts","webpack://wavefunctioncollapse/./src/PieceObject.ts","webpack://wavefunctioncollapse/./src/SuperImposedState.ts","webpack://wavefunctioncollapse/./src/WFCConfig.ts","webpack://wavefunctioncollapse/./src/WFCData.ts","webpack://wavefunctioncollapse/./src/WFCRender.ts","webpack://wavefunctioncollapse/./src/WFCRunner.ts","webpack://wavefunctioncollapse/./src/WFCTiles.ts","webpack://wavefunctioncollapse/./src/metadata/render/ sync ^\\.\\/.*\\.json$","webpack://wavefunctioncollapse/./src/metadata/sets/ sync ^\\.\\/.*\\.json$","webpack://wavefunctioncollapse/./src/metadata/tiles/ sync ^\\.\\/.*\\.json$","webpack://wavefunctioncollapse/webpack/bootstrap","webpack://wavefunctioncollapse/webpack/runtime/define property getters","webpack://wavefunctioncollapse/webpack/runtime/hasOwnProperty shorthand","webpack://wavefunctioncollapse/webpack/runtime/make namespace object","webpack://wavefunctioncollapse/./src/index.ts"],"sourcesContent":["export var Direction;\r\n(function (Direction) {\r\n    Direction[Direction[\"top\"] = 0] = \"top\";\r\n    Direction[Direction[\"right\"] = 1] = \"right\";\r\n    Direction[Direction[\"bottom\"] = 2] = \"bottom\";\r\n    Direction[Direction[\"left\"] = 3] = \"left\";\r\n})(Direction || (Direction = {}));\r\n","export class PieceObject {\r\n    constructor(key, name, rotation, validNeighbors, edgeblacklist, weight) {\r\n        this.key = key;\r\n        this.name = name;\r\n        this.rotation = rotation;\r\n        this.validNeighbors = validNeighbors;\r\n        this.edgeblacklist = edgeblacklist;\r\n        this.weight = weight;\r\n    }\r\n}\r\n","export var SuperImposedState;\r\n(function (SuperImposedState) {\r\n    SuperImposedState[SuperImposedState[\"None\"] = 0] = \"None\";\r\n    SuperImposedState[SuperImposedState[\"Layered\"] = 1] = \"Layered\";\r\n    SuperImposedState[SuperImposedState[\"LayeredSorted\"] = 2] = \"LayeredSorted\";\r\n    SuperImposedState[SuperImposedState[\"Grid\"] = 3] = \"Grid\";\r\n    SuperImposedState[SuperImposedState[\"GridScaled\"] = 4] = \"GridScaled\";\r\n    SuperImposedState[SuperImposedState[\"GridAlpha\"] = 5] = \"GridAlpha\";\r\n})(SuperImposedState || (SuperImposedState = {}));\r\n","export class WFCConfig {\r\n    constructor() {\r\n        this.maxRetryCount = 10;\r\n        this.maxDepth = 100;\r\n        this.tileScale = 40;\r\n        this.fast = false;\r\n        this.runSpeed = 10;\r\n        this.runLoop = 30;\r\n        this.tilesHeight = 30;\r\n        this.tilesWidth = 30;\r\n        this.superImposed = 1;\r\n        this.useMouse = false;\r\n        this.tileName = 'Knots';\r\n        this.set = 'all';\r\n    }\r\n}\r\n","export class WFCData {\r\n    constructor() {\r\n        this.tileSets = {};\r\n        this.tilePieces = {};\r\n    }\r\n}\r\n","import { SuperImposedState } from './SuperImposedState';\r\nimport { WFCConfig } from './WFCConfig';\r\nimport { WFCRunner } from './WFCRunner';\r\nimport { WFCTiles } from './WFCTiles';\r\nexport class WFCRender {\r\n    constructor(canvasId) {\r\n        this.config = new WFCConfig();\r\n        this.wfc = new WFCTiles();\r\n        this.halfScaleHeight = this.config.tileScale / 2;\r\n        this.halfScaleWidth = this.config.tileScale / 2;\r\n        this.imagesMap = {};\r\n        this.wfcCallback = () => {\r\n            this.draw();\r\n        };\r\n        this.canvas = document.getElementById(canvasId);\r\n        this.ctx = this.canvas.getContext(\"2d\");\r\n    }\r\n    preloadImage(src) {\r\n        return new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = (event) => resolve(image);\r\n            image.onerror = (event) => reject();\r\n            image.src = src;\r\n            return image;\r\n        });\r\n    }\r\n    getAvailableTiles() {\r\n        return Object.keys(this.wfc.wfcData.tileSets);\r\n    }\r\n    getSuperImposedStates() {\r\n        return SuperImposedState;\r\n    }\r\n    getAvailableSets(tileName) {\r\n        var sets = this.wfc.wfcData.tileSets[tileName];\r\n        if (sets == null)\r\n            return null;\r\n        return Object.keys(sets);\r\n    }\r\n    getTileSets() {\r\n        return this.wfc.wfcData.tileSets;\r\n    }\r\n    getWFCData() {\r\n        return this.wfc.wfcData;\r\n    }\r\n    getWFC() {\r\n        return this.wfc;\r\n    }\r\n    async init(config) {\r\n        console.clear();\r\n        this.config = config;\r\n        this.wfc = new WFCTiles();\r\n        this.wfc.init(config);\r\n        this.wfcRunner = new WFCRunner(config, this.wfc, this.wfcCallback);\r\n        await this.initImageData();\r\n        let ctx = this.ctx;\r\n        let canvas = this.canvas;\r\n        this.halfScaleHeight = this.config.tileScale / 2;\r\n        this.halfScaleWidth = this.config.tileScale / 2;\r\n        canvas.height = this.config.tilesHeight * this.config.tileScale;\r\n        canvas.width = this.config.tilesWidth * this.config.tileScale;\r\n        ctx.fillStyle = \"transparent\";\r\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n    }\r\n    async initImageData() {\r\n        let pieces = this.wfc.wfcData.tilePieces[this.config.tileName];\r\n        let tileImages = require('./metadata/render/' + this.config.tileName + '.json');\r\n        let tileImageMap = tileImages.reduce((tileMap, tileImage) => {\r\n            tileMap[tileImage.name] = tileImage.imgsrc;\r\n            return tileMap;\r\n        }, {});\r\n        let loadImagesAsync = pieces.map(async (x) => {\r\n            return {\r\n                name: x.name,\r\n                img: await this.preloadImage('tiles/' + this.config.tileName + '/' + tileImageMap[x.name])\r\n            };\r\n        });\r\n        this.imagesMap = (await Promise.all(loadImagesAsync)).reduce((piecesMap, piece) => {\r\n            piecesMap[piece.name] = piece.img;\r\n            return piecesMap;\r\n        }, {});\r\n    }\r\n    initDraw() {\r\n        this.startOver();\r\n    }\r\n    startOver() {\r\n        this.wfc.reset();\r\n        this.reset();\r\n        this.startWFCLoop(this.config.runSpeed);\r\n    }\r\n    reset() {\r\n        this.ctx.fillStyle = \"white\";\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n    startWFCLoop(interval) {\r\n        if (this.config.useMouse) {\r\n            document.body.addEventListener('click', () => this.wfcRunner.runWFC(), true);\r\n        }\r\n        this.draw();\r\n        this.wfcRunner.startWFCLoop(interval);\r\n    }\r\n    draw() {\r\n        this.ctx.save();\r\n        this.drawTiles();\r\n        this.ctx.restore();\r\n    }\r\n    drawTiles() {\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.wfc.tiles.forEach((column, columnIndex) => {\r\n            column.forEach((tile, rowIndex) => {\r\n                if (!this.config.fast) {\r\n                    if (tile.validPieces) {\r\n                        let validCount = tile.validPieces.length;\r\n                        if (tile.validPieces.length > 0) {\r\n                            if (this.config.superImposed == SuperImposedState.Layered) {\r\n                                //superimposed 1 - on top of each\r\n                                tile.validPieces.forEach((key) => {\r\n                                    let piece = this.wfc.piecesMap[key];\r\n                                    let tileImage = this.imagesMap[piece.name];\r\n                                    this.drawSuperimposed(tileImage, columnIndex, rowIndex, piece.rotation, validCount);\r\n                                });\r\n                            }\r\n                            else if (this.config.superImposed == SuperImposedState.GridScaled) {\r\n                                //superimposed 2 - grid\r\n                                let gridSize = Math.ceil(Math.sqrt(validCount));\r\n                                tile.validPieces.forEach((key, index) => {\r\n                                    let piece = this.wfc.piecesMap[key];\r\n                                    let tileImage = this.imagesMap[piece.name];\r\n                                    this.drawSuperimposedPartGrid(tileImage, columnIndex, rowIndex, gridSize, index, piece.rotation, validCount, 0.4);\r\n                                });\r\n                            }\r\n                            else if (this.config.superImposed == SuperImposedState.Grid) {\r\n                                //superimposed 3 - grid without scaling\r\n                                validCount = Object.keys(this.wfc.piecesMap).length;\r\n                                let gridSize = Math.ceil(Math.sqrt(validCount));\r\n                                tile.validPieces.forEach((key, index) => {\r\n                                    let piece = this.wfc.piecesMap[key];\r\n                                    let tileImage = this.imagesMap[piece.name];\r\n                                    this.drawSuperimposedPartGrid(tileImage, columnIndex, rowIndex, gridSize, index, piece.rotation, validCount, 0.4);\r\n                                });\r\n                            }\r\n                            else if (this.config.superImposed == SuperImposedState.None) {\r\n                                //superimposed 4 - none\r\n                            }\r\n                            else if (this.config.superImposed == SuperImposedState.LayeredSorted) {\r\n                                //superimposed 5 - layered sorted\r\n                                let sortedValid = tile.validPieces.sort((a, b) => {\r\n                                    let pieceA = this.wfc.piecesMap[a];\r\n                                    let pieceB = this.wfc.piecesMap[b];\r\n                                    return pieceB.weight - pieceA.weight;\r\n                                });\r\n                                sortedValid.forEach((key) => {\r\n                                    let piece = this.wfc.piecesMap[key];\r\n                                    let tileImage = this.imagesMap[piece.name];\r\n                                    this.drawSuperimposed(tileImage, columnIndex, rowIndex, piece.rotation, validCount);\r\n                                });\r\n                            }\r\n                            else if (this.config.superImposed == SuperImposedState.GridAlpha) {\r\n                                //superimposed 6 - grid scaled alpha\r\n                                let minWeight = 999;\r\n                                let maxWeight = 0;\r\n                                let sortedValid = tile.validPieces.sort((a, b) => {\r\n                                    let pieceA = this.wfc.piecesMap[a];\r\n                                    let pieceB = this.wfc.piecesMap[b];\r\n                                    let weight = pieceA.weight;\r\n                                    if (minWeight > weight) {\r\n                                        minWeight = weight;\r\n                                    }\r\n                                    if (maxWeight < weight) {\r\n                                        maxWeight = weight;\r\n                                    }\r\n                                    return pieceB.weight - pieceA.weight;\r\n                                });\r\n                                sortedValid.forEach((key, index) => {\r\n                                    let piece = this.wfc.piecesMap[key];\r\n                                    let tileImage = this.imagesMap[piece.name];\r\n                                    let weight = piece.weight;\r\n                                    let weightPercent = ((weight - minWeight)) / (maxWeight - minWeight);\r\n                                    let adjustedAlpha = (weightPercent * (0.6 - 0.2)) + 0.2;\r\n                                    let gridSize = Math.ceil(Math.sqrt(validCount));\r\n                                    this.drawSuperimposedPartGrid(tileImage, columnIndex, rowIndex, gridSize, index, piece.rotation, validCount, adjustedAlpha);\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (tile.key != undefined) {\r\n                    let key = tile.key;\r\n                    let piece = this.wfc.piecesMap[key];\r\n                    let tileImage = this.imagesMap[piece.name];\r\n                    this.drawTile(tileImage, columnIndex, rowIndex, tile.rotation);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    drawImgGrid(img, x, y, rotation, alpha) {\r\n        this.ctx.save();\r\n        this.ctx.globalAlpha = alpha;\r\n        this.ctx.translate((this.config.tileScale * x) + this.halfScaleWidth, (this.config.tileScale * y) + this.halfScaleHeight);\r\n        this.ctx.rotate((rotation * 90) * (Math.PI / 180));\r\n        this.ctx.drawImage(img, -this.halfScaleWidth, -this.halfScaleHeight, this.config.tileScale, this.config.tileScale);\r\n        this.ctx.restore();\r\n    }\r\n    drawTile(img, x, y, rotation) {\r\n        this.drawImgGrid(img, x, y, rotation, 1);\r\n    }\r\n    drawSuperimposed(img, x, y, rotation, possible) {\r\n        this.drawImgGrid(img, x, y, rotation, 0.9 / possible);\r\n    }\r\n    drawSuperimposedWeighted(img, x, y, rotation, possible, alpha) {\r\n        this.drawImgGrid(img, x, y, rotation, alpha);\r\n    }\r\n    drawSuperimposedPartGrid(img, x, y, gridSize, gridIndex, rotation, possible, alpha) {\r\n        let width = this.config.tileScale / gridSize;\r\n        let height = this.config.tileScale / (gridSize);\r\n        let newX = (this.config.tileScale * x) + ((gridIndex % gridSize) * width);\r\n        let newY = (this.config.tileScale * y) + ((Math.floor(gridIndex / gridSize)) * height);\r\n        this.drawImg(img, newX, newY, width, height, rotation, alpha);\r\n    }\r\n    drawImg(img, x, y, width, height, rotation, alpha) {\r\n        this.ctx.save();\r\n        this.ctx.globalAlpha = alpha;\r\n        this.ctx.translate(x + (width / 2), y + (height / 2));\r\n        this.ctx.rotate((rotation * 90) * (Math.PI / 180));\r\n        this.ctx.drawImage(img, -(width / 2), -(height / 2), width, height);\r\n        this.ctx.restore();\r\n    }\r\n}\r\n","export class WFCRunner {\r\n    constructor(config, wfc, callback) {\r\n        this.retryCount = 0;\r\n        this.stopRunning = true;\r\n        this.wfcLoop = undefined;\r\n        this.hasRunWFC = () => {\r\n            this.callback();\r\n        };\r\n        this.config = config;\r\n        this.wfc = wfc;\r\n        this.callback = callback;\r\n    }\r\n    getTilePositionsAsEntropyGroups() {\r\n        let entropyGroups = {};\r\n        this.wfc.tiles.forEach((column, x) => {\r\n            column.forEach((tile, y) => {\r\n                if (tile.validPieces) {\r\n                    let entropy = tile.validPieces.length;\r\n                    if (entropyGroups[entropy] == undefined) {\r\n                        entropyGroups[entropy] = [];\r\n                    }\r\n                    entropyGroups[entropy].push({ x: x, y: y });\r\n                }\r\n            });\r\n        });\r\n        return entropyGroups;\r\n    }\r\n    noValidFound() {\r\n        this.retryCount++;\r\n        this.stopWFCLoop();\r\n        if (this.retryCount <= this.config.maxRetryCount) {\r\n            this.startOver();\r\n        }\r\n        else {\r\n            console.log('not possible to solve within ' + this.config.maxRetryCount + ' retries');\r\n        }\r\n    }\r\n    runWFC() {\r\n        for (var i = 0; (i < this.config.runLoop) || this.config.fast; i++) {\r\n            let stop = this.checkForStop();\r\n            if (stop) {\r\n                this.hasRunWFC();\r\n                return;\r\n            }\r\n            if (this.stopRunning)\r\n                return;\r\n            let entropyGroups = this.getTilePositionsAsEntropyGroups();\r\n            let entropyKeys = Object.keys(entropyGroups);\r\n            if (entropyKeys.length == 0) {\r\n                this.stopWFCLoop();\r\n                return;\r\n            }\r\n            let lowestEntropyKey = Number(entropyKeys[0]);\r\n            let lowestEntroyGroup = entropyGroups[lowestEntropyKey];\r\n            let randomPositionFromLowestEntropyGroup = this.getRandomElementFromArray(lowestEntroyGroup);\r\n            let x = randomPositionFromLowestEntropyGroup.x;\r\n            let y = randomPositionFromLowestEntropyGroup.y;\r\n            let currentTile = this.wfc.tiles[x][y];\r\n            if (currentTile.validPieces != undefined) {\r\n                if (currentTile.validPieces.length == 0) {\r\n                    this.noValidFound();\r\n                    return false;\r\n                }\r\n                let randomPiece = Math.floor(Math.random() * currentTile.validPieces.length);\r\n                let tileKey = this.getRandomElementFromArrayWeigted(currentTile.validPieces);\r\n                if (tileKey == null) {\r\n                    this.noValidFound();\r\n                    return false;\r\n                }\r\n                let piece = this.wfc.piecesMap[tileKey];\r\n                this.wfc.tiles[x][y] = piece;\r\n                if (piece == undefined) {\r\n                    console.log('piece', x, y, piece, tileKey, randomPiece, currentTile.validPieces);\r\n                }\r\n                let validation = this.runValidation(x, y, [piece]);\r\n                if (validation == null) {\r\n                    break;\r\n                }\r\n                let depth = 0;\r\n                while (validation.length > 0 && depth < this.config.maxDepth) {\r\n                    let newValidations = [];\r\n                    if (validation.length > 0) {\r\n                        validation.forEach((v) => {\r\n                            let validationTile = this.wfc.tiles[v.x][v.y];\r\n                            let validationTilePieces = validationTile.validPieces;\r\n                            let pieces = validationTilePieces.map((tileKey) => {\r\n                                return this.wfc.piecesMap[tileKey];\r\n                            });\r\n                            let innerValidation = this.runValidation(v.x, v.y, pieces);\r\n                            newValidations.push(innerValidation);\r\n                        });\r\n                    }\r\n                    let newValidationsConcat = [].concat.apply([], newValidations);\r\n                    let newValidationsSet = Array.from(new Set(newValidationsConcat));\r\n                    depth += 1;\r\n                    validation = newValidationsSet;\r\n                }\r\n            }\r\n        }\r\n        this.hasRunWFC();\r\n    }\r\n    runValidation(x, y, pieces) {\r\n        let recheck = [];\r\n        let neighbors = [];\r\n        if (y != 0) {\r\n            neighbors.push({ direction: 'top', tile: this.wfc.tiles[x][y - 1] });\r\n        }\r\n        if (x != this.config.tilesWidth - 1) {\r\n            neighbors.push({ direction: 'right', tile: this.wfc.tiles[x + 1][y] });\r\n        }\r\n        if (y != this.config.tilesHeight - 1) {\r\n            neighbors.push({ direction: 'bottom', tile: this.wfc.tiles[x][y + 1] });\r\n        }\r\n        if (x != 0) {\r\n            neighbors.push({ direction: 'left', tile: this.wfc.tiles[x - 1][y] });\r\n        }\r\n        neighbors.forEach((neighbor) => {\r\n            if (neighbor.tile.validPieces) {\r\n                let validBefore = neighbor.tile.validPieces.length;\r\n                let validArray = [];\r\n                pieces.forEach((piece) => {\r\n                    validArray.push(neighbor.tile.validPieces\r\n                        .filter((validPieceToCheck) => {\r\n                        return piece.validNeighbors[neighbor.direction].includes(validPieceToCheck);\r\n                    }));\r\n                });\r\n                let validArrayConcat = [].concat.apply([], validArray);\r\n                let uniquevalidArraySet = Array.from(new Set(validArrayConcat));\r\n                neighbor.tile.validPieces = uniquevalidArraySet;\r\n                var validAfter = neighbor.tile.validPieces.length;\r\n                if (validBefore != validAfter) {\r\n                    recheck.push(neighbor.tile.position);\r\n                }\r\n            }\r\n        });\r\n        return recheck;\r\n    }\r\n    checkForStop() {\r\n        let stop = true;\r\n        this.wfc.tiles.forEach((column, columnIndex) => {\r\n            column.forEach((tile, rowIndex) => {\r\n                if (tile.key == undefined) {\r\n                    stop = false;\r\n                    return false;\r\n                }\r\n            });\r\n            if (!stop) {\r\n                return false;\r\n            }\r\n        });\r\n        if (stop) {\r\n            console.log('checkForStop', 'return true');\r\n            console.log('Found solution after ' + this.retryCount + ' retries');\r\n            this.stopWFCLoop();\r\n            return true;\r\n        }\r\n        return stop;\r\n    }\r\n    stopWFCLoop() {\r\n        this.stopRunning = true;\r\n        clearInterval(this.wfcLoop);\r\n    }\r\n    startOver() {\r\n        this.wfc.reset();\r\n        this.startWFCLoop(this.config.runSpeed);\r\n    }\r\n    startWFCLoop(interval) {\r\n        this.stopRunning = false;\r\n        if (this.config.useMouse) {\r\n        }\r\n        else {\r\n            this.wfcLoop = setInterval(() => {\r\n                this.runWFC();\r\n            }, interval);\r\n        }\r\n    }\r\n    getRandomElementFromArray(array) {\r\n        return array[Math.floor(Math.random() * array.length)];\r\n    }\r\n    getRandomElementFromArrayWeigted(array) {\r\n        let summed = [];\r\n        let sumCount = 0;\r\n        let lastSum = 0;\r\n        array.forEach((x, i) => {\r\n            let weight = this.wfc.piecesMap[x].weight;\r\n            if (weight > 0) {\r\n                lastSum = sumCount;\r\n                sumCount += weight;\r\n                summed.push({\r\n                    'key': x,\r\n                    'minsum': lastSum,\r\n                    'maxsum': sumCount\r\n                });\r\n            }\r\n        });\r\n        if (summed.length == 0)\r\n            return null;\r\n        let rnd = Math.random() * sumCount;\r\n        let selected = summed.find((x) => {\r\n            return x.minsum <= rnd && x.maxsum > rnd;\r\n        });\r\n        if (selected == undefined) {\r\n            console.log('summed', summed);\r\n        }\r\n        return selected.key;\r\n    }\r\n}\r\n","import { Direction } from './Direction';\r\nimport { PieceObject } from './PieceObject';\r\nimport { WFCConfig } from './WFCConfig';\r\nimport { WFCData } from './WFCData';\r\nexport class WFCTiles {\r\n    constructor() {\r\n        this.wfcData = new WFCData();\r\n        this.config = new WFCConfig();\r\n        this.piecesMap = {};\r\n        this.tiles = [];\r\n    }\r\n    async init(config) {\r\n        console.clear();\r\n        this.config = config;\r\n        this.loadTiles();\r\n    }\r\n    loadTiles() {\r\n        this.wfcData = new WFCData();\r\n        this.wfcData.tilePieces = {};\r\n        this.wfcData.tileSets = {};\r\n        var tileNames = [\"Castle\", \"Circles\", \"Circuit\", \"FloorPlan\", \"Knots\", \"Rooms\", \"Summer\"];\r\n        for (let tileIndex in tileNames) {\r\n            const tile = tileNames[tileIndex];\r\n            this.wfcData.tilePieces[tile] = require('./metadata/tiles/' + tile + '.json');\r\n            this.wfcData.tileSets[tile] = require('./metadata/sets/' + tile + '.json');\r\n        }\r\n    }\r\n    async initTileData() {\r\n        let pieces = this.wfcData.tilePieces[this.config.tileName];\r\n        let sets = this.wfcData.tileSets[this.config.tileName];\r\n        let currentSet = sets[this.config.set];\r\n        Object.entries(currentSet).forEach((value) => {\r\n            let pieceName = value[0];\r\n            let properties = value[1];\r\n            if (properties.rotations != undefined) {\r\n                pieces.find(x => x.name == pieceName).rotations = properties.rotations;\r\n            }\r\n            if (properties.weight != undefined) {\r\n                pieces.find(x => x.name == pieceName).weight = properties.weight;\r\n            }\r\n            if (properties.edgeblacklist != undefined) {\r\n                pieces.find(x => x.name == pieceName).edgeblacklist = properties.edgeblacklist;\r\n            }\r\n        });\r\n        let mappedPieces = pieces.reduce((piecesMap, piece) => {\r\n            if (currentSet[piece.name] == undefined) {\r\n                return piecesMap;\r\n            }\r\n            console.log('piece', piece);\r\n            let pieceSockets = piece.socket;\r\n            piece.socketmatching = {};\r\n            piece.blacklistedNeighbors = {};\r\n            piece.rotations.forEach((rotation) => {\r\n                let socketMatchObject = {};\r\n                let blacklistedNeighbors = {};\r\n                Object.keys(Direction).forEach((direction, index) => {\r\n                    if (!isNaN(Number(direction)))\r\n                        return;\r\n                    let directionsCount = (Object.keys(Direction).length / 2);\r\n                    let directionIndex = Direction[direction];\r\n                    let rotationMoved = (directionIndex - rotation + directionsCount) % directionsCount;\r\n                    let flipped = directionIndex >= (directionsCount / 2);\r\n                    let sockets = pieceSockets[Direction[rotationMoved]];\r\n                    (Array.isArray(sockets) ? sockets : [sockets]).forEach((socket) => {\r\n                        (socketMatchObject[direction] || (socketMatchObject[direction] = [])).push(flipped ? socket.split(\"\").reverse().join(\"\") : socket);\r\n                    });\r\n                });\r\n                if (piece.blacklist) {\r\n                    Object.entries(piece.blacklist).forEach((blacklist) => {\r\n                        let blackListDirection = blacklist[0];\r\n                        let blackListValue = blacklist[1];\r\n                        let blackListIndex = Direction[blackListDirection];\r\n                        let directionsCount = (Object.keys(Direction).length / 2);\r\n                        let rotationBlacklistingIndex = (blackListIndex + rotation) % directionsCount;\r\n                        let rotationBlacklisting = Direction[rotationBlacklistingIndex];\r\n                        Object.entries(blackListValue).forEach((blacklistPiece) => {\r\n                            let blackListPieceName = blacklistPiece[0];\r\n                            let blackListPieceRotations = blacklistPiece[1];\r\n                            blackListPieceRotations.forEach((blackListPieceRotation) => {\r\n                                let blackListPieceNameWithRotation = blackListPieceName + \"_\" + (blackListPieceRotation + rotation) % directionsCount;\r\n                                if (blacklistedNeighbors[rotationBlacklisting] == undefined) {\r\n                                    blacklistedNeighbors[rotationBlacklisting] = [];\r\n                                }\r\n                                blacklistedNeighbors[rotationBlacklisting].push(blackListPieceNameWithRotation);\r\n                            });\r\n                        });\r\n                    });\r\n                }\r\n                piece.blacklistedNeighbors[rotation] = blacklistedNeighbors;\r\n                piece.socketmatching[rotation] = socketMatchObject;\r\n            });\r\n            piecesMap[piece.name] = piece;\r\n            return piecesMap;\r\n        }, {});\r\n        let socketBuckets = {};\r\n        Object.entries(mappedPieces).forEach((mappedPieceValue) => {\r\n            let pieceName = mappedPieceValue[0];\r\n            let piece = mappedPieceValue[1];\r\n            if (piece.socketmatching != undefined) {\r\n                Object.entries(piece.socketmatching).forEach((socketMatchValue) => {\r\n                    let socketDirection = parseInt(socketMatchValue[0]);\r\n                    let socketMatch = socketMatchValue[1];\r\n                    Object.entries(socketMatch).forEach((socket) => {\r\n                        let socketDirectionInner = socket[0];\r\n                        let socketMatchInnerValueArray = socket[1];\r\n                        let socketDirectionInnerIndex = Direction[socketDirectionInner];\r\n                        let directionsCount = (Object.keys(Direction).length / 2);\r\n                        let socketDirectionPolarIndex = (socketDirectionInnerIndex + directionsCount / 2) % directionsCount;\r\n                        let socketDirectionPolar = Direction[socketDirectionPolarIndex];\r\n                        socketMatchInnerValueArray.forEach((socketMatchInnerValue) => {\r\n                            if (socketBuckets[socketMatchInnerValue] == undefined) {\r\n                                let innerObject = {};\r\n                                socketBuckets[socketMatchInnerValue] = innerObject;\r\n                            }\r\n                            if (socketBuckets[socketMatchInnerValue][socketDirectionPolar] == undefined) {\r\n                                socketBuckets[socketMatchInnerValue][socketDirectionPolar] = [];\r\n                            }\r\n                            socketBuckets[socketMatchInnerValue][socketDirectionPolar].push(pieceName + \"_\" + socketDirection);\r\n                        });\r\n                    });\r\n                });\r\n            }\r\n        });\r\n        this.piecesMap = Object.entries(mappedPieces).reduce((piecesMap, piecePair) => {\r\n            let piece = piecePair[1];\r\n            if (currentSet[piece.name] == undefined) {\r\n                return piecesMap;\r\n            }\r\n            if (piece.rotations == undefined) {\r\n                piece.rotations = [0];\r\n            }\r\n            piece.rotations.forEach((rotation) => {\r\n                var _a, _b;\r\n                let pieceName = piece.name + \"_\" + rotation;\r\n                let validNeighbors = {\r\n                    top: [],\r\n                    right: [],\r\n                    bottom: [],\r\n                    left: []\r\n                };\r\n                if (piece.socketmatching != undefined) {\r\n                    if (piece.socketmatching[rotation] != undefined) {\r\n                        let socketMatch = piece.socketmatching[rotation];\r\n                        Object.entries(socketMatch).forEach((socketPair) => {\r\n                            let socketDirection = socketPair[0];\r\n                            let sockets = socketPair[1];\r\n                            sockets.forEach((socket) => {\r\n                                if (socketBuckets[socket] != undefined && socketBuckets[socket][socketDirection] != undefined) {\r\n                                    let validPiecesForSocket = socketBuckets[socket][socketDirection];\r\n                                    validPiecesForSocket.forEach((validPiece) => {\r\n                                        var _a;\r\n                                        let blackList = (_a = piece.blacklistedNeighbors[rotation][socketDirection]) !== null && _a !== void 0 ? _a : [];\r\n                                        if (!validNeighbors[socketDirection].includes(validPiece) && !blackList.includes(validPiece)) {\r\n                                            validNeighbors[socketDirection].push(validPiece);\r\n                                        }\r\n                                    });\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n                let weight = (_a = piece.weight) !== null && _a !== void 0 ? _a : 1;\r\n                if (Array.isArray(piece.weight)) {\r\n                    weight = (_b = weight[rotation]) !== null && _b !== void 0 ? _b : 1;\r\n                }\r\n                let edgeBlackList = null;\r\n                if (piece.edgeblacklist) {\r\n                    edgeBlackList = piece.edgeblacklist.map((direction) => {\r\n                        let dir = Direction[direction];\r\n                        let directionsCount = (Object.keys(Direction).length / 2);\r\n                        let newDir = (dir + rotation) % directionsCount;\r\n                        return Direction[newDir];\r\n                    });\r\n                }\r\n                piecesMap[pieceName] = new PieceObject(piece.name + \"_\" + rotation, piece.name, rotation, validNeighbors, edgeBlackList, weight);\r\n            });\r\n            return piecesMap;\r\n        }, {});\r\n        return true;\r\n    }\r\n    reset() {\r\n        let piecesKeys = Object.keys(this.piecesMap);\r\n        let startingTile = {\r\n            validPieces: piecesKeys,\r\n        };\r\n        this.tiles = Array.from({ length: this.config.tilesWidth }, (a, x) => {\r\n            return Array.from({ length: this.config.tilesHeight }, (b, y) => {\r\n                var edges = [];\r\n                if (x == 0)\r\n                    edges.push('left');\r\n                if (y == 0)\r\n                    edges.push('top');\r\n                if (x == this.config.tilesWidth - 1)\r\n                    edges.push('right');\r\n                if (y == this.config.tilesHeight - 1)\r\n                    edges.push('bottom');\r\n                if (edges.length > 0) {\r\n                    let validPieces = startingTile.validPieces.filter((pieceName) => {\r\n                        let piece = this.piecesMap[pieceName];\r\n                        if (piece.edgeblacklist) {\r\n                            return !edges.some(v => piece.edgeblacklist.includes(v));\r\n                        }\r\n                        else {\r\n                            return true;\r\n                        }\r\n                    });\r\n                    return {\r\n                        position: { x: x, y: y },\r\n                        validPieces: validPieces\r\n                    };\r\n                }\r\n                else {\r\n                    return {\r\n                        position: { x: x, y: y },\r\n                        validPieces: [...startingTile.validPieces]\r\n                    };\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n","var map = {\n\t\"./Castle.json\": \"./src/metadata/render/Castle.json\",\n\t\"./Circles.json\": \"./src/metadata/render/Circles.json\",\n\t\"./Circuit.json\": \"./src/metadata/render/Circuit.json\",\n\t\"./FloorPlan.json\": \"./src/metadata/render/FloorPlan.json\",\n\t\"./Knots.json\": \"./src/metadata/render/Knots.json\",\n\t\"./Rooms.json\": \"./src/metadata/render/Rooms.json\",\n\t\"./Summer.json\": \"./src/metadata/render/Summer.json\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/metadata/render sync recursive ^\\\\.\\\\/.*\\\\.json$\";","var map = {\n\t\"./Castle.json\": \"./src/metadata/sets/Castle.json\",\n\t\"./Circles.json\": \"./src/metadata/sets/Circles.json\",\n\t\"./Circuit.json\": \"./src/metadata/sets/Circuit.json\",\n\t\"./FloorPlan.json\": \"./src/metadata/sets/FloorPlan.json\",\n\t\"./Knots.json\": \"./src/metadata/sets/Knots.json\",\n\t\"./Rooms.json\": \"./src/metadata/sets/Rooms.json\",\n\t\"./Summer.json\": \"./src/metadata/sets/Summer.json\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/metadata/sets sync recursive ^\\\\.\\\\/.*\\\\.json$\";","var map = {\n\t\"./Castle.json\": \"./src/metadata/tiles/Castle.json\",\n\t\"./Circles.json\": \"./src/metadata/tiles/Circles.json\",\n\t\"./Circuit.json\": \"./src/metadata/tiles/Circuit.json\",\n\t\"./FloorPlan.json\": \"./src/metadata/tiles/FloorPlan.json\",\n\t\"./Knots.json\": \"./src/metadata/tiles/Knots.json\",\n\t\"./Rooms.json\": \"./src/metadata/tiles/Rooms.json\",\n\t\"./Summer.json\": \"./src/metadata/tiles/Summer.json\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/metadata/tiles sync recursive ^\\\\.\\\\/.*\\\\.json$\";","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { WFCTiles } from './WFCTiles';\r\nimport { WFCRender } from \"./WFCRender\";\r\nwindow.getWFCRender = function getWFCRender(canvasId) {\r\n    return new WFCRender(canvasId);\r\n};\r\nwindow.getWFC = function getWFC() {\r\n    return new WFCTiles();\r\n};\r\n"],"names":[],"sourceRoot":""}