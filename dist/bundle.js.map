{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;;;;;;;;;;;;;;;;;ACRS;AACjD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6EAAQ,IAAmB,UAAU,OAAO,CAAC;AACjF,kCAAkC,4EAAQ,IAAkB,UAAU,OAAO,CAAC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yBAAyB;AAC3D,gCAAgC,0BAA0B;AAC1D;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAA8C;AAC3E;AACA;AACA,6BAA6B,gDAAgD;AAC7E;AACA;AACA,6BAA6B,iDAAiD;AAC9E;AACA;AACA,6BAA6B,+CAA+C;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yEAAyB;AAC1E;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,sDAAsD,4EAA4B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,sDAAsD,sEAAsB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,sDAAsD,sEAAsB;AAC5E;AACA;AACA,sDAAsD,+EAA+B;AACrF;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,sDAAsD,2EAA2B;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UC5BA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;ACN4B;AAC5B,iEAAe,qCAAG,EAAC;AACnB;AACA,eAAe,qCAAG;AAClB","sources":["webpack://wavefunctioncollapse/./src/SuperImposedState.ts","webpack://wavefunctioncollapse/./src/wfc.ts","webpack://wavefunctioncollapse/./src/metadata/sets/ sync ^\\.\\/.*\\.json$","webpack://wavefunctioncollapse/./src/metadata/tiles/ sync ^\\.\\/.*\\.json$","webpack://wavefunctioncollapse/webpack/bootstrap","webpack://wavefunctioncollapse/webpack/runtime/define property getters","webpack://wavefunctioncollapse/webpack/runtime/hasOwnProperty shorthand","webpack://wavefunctioncollapse/webpack/runtime/make namespace object","webpack://wavefunctioncollapse/./src/index.ts"],"sourcesContent":["export var SuperImposedState;\r\n(function (SuperImposedState) {\r\n    SuperImposedState[SuperImposedState[\"None\"] = 0] = \"None\";\r\n    SuperImposedState[SuperImposedState[\"Layered\"] = 1] = \"Layered\";\r\n    SuperImposedState[SuperImposedState[\"LayeredSorted\"] = 2] = \"LayeredSorted\";\r\n    SuperImposedState[SuperImposedState[\"Grid\"] = 3] = \"Grid\";\r\n    SuperImposedState[SuperImposedState[\"GridScaled\"] = 4] = \"GridScaled\";\r\n    SuperImposedState[SuperImposedState[\"GridAlpha\"] = 5] = \"GridAlpha\";\r\n})(SuperImposedState || (SuperImposedState = {}));\r\n","import { SuperImposedState } from './SuperImposedState';\r\nexport class WFC {\r\n    constructor(canvasId) {\r\n        this.maxRetryCount = 10;\r\n        this.maxDepth = 100;\r\n        this.tileScaleHeight = 40;\r\n        this.tileScaleWidth = 40;\r\n        this.fast = false;\r\n        this.runSpeed = 10;\r\n        this.runLoop = 30;\r\n        this.tilesHeight = 30;\r\n        this.tilesWidth = 30;\r\n        this.superImposed = 1;\r\n        this.useMouse = false;\r\n        this.tileName = 'Knots';\r\n        this.set = 'all';\r\n        this.halfScaleHeight = this.tileScaleHeight / 2;\r\n        this.halfScaleWidth = this.tileScaleWidth / 2;\r\n        this.pieces = [];\r\n        this.piecesMap = {};\r\n        this.imagesMap = {};\r\n        this.tiles = [];\r\n        this.directionsMapIntToKey = [\r\n            'top',\r\n            'right',\r\n            'bottom',\r\n            'left'\r\n        ];\r\n        this.directionsMapKeyToInt = {\r\n            'top': 0,\r\n            'right': 1,\r\n            'bottom': 2,\r\n            'left': 3\r\n        };\r\n        this.sets = {};\r\n        this.currentSet = {} = {};\r\n        this.retryCount = 0;\r\n        this.tileSets = {};\r\n        this.tilePieces = {};\r\n        this.stopRunning = true;\r\n        this.wfcLoop = undefined;\r\n        this.canvas = document.getElementById(canvasId);\r\n        this.ctx = this.canvas.getContext(\"2d\");\r\n    }\r\n    preloadImage(src) {\r\n        return new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = (event) => resolve(image);\r\n            image.onerror = (event) => reject();\r\n            image.src = src;\r\n            return image;\r\n        });\r\n    }\r\n    getAvailableTiles() {\r\n        return Object.keys(this.tileSets);\r\n    }\r\n    getSuperImposedStates() {\r\n        return SuperImposedState;\r\n    }\r\n    getAvailableSets(tileName) {\r\n        var sets = this.tileSets[tileName];\r\n        if (sets == null)\r\n            return null;\r\n        return Object.keys(sets);\r\n    }\r\n    getTileSets() {\r\n        return this.tileSets;\r\n    }\r\n    loadTiles() {\r\n        this.tilePieces = {};\r\n        this.tileSets = {};\r\n        var tileNames = [\"Castle\", \"Circles\", \"Circuit\", \"FloorPlan\", \"Knots\", \"Rooms\", \"Summer\"];\r\n        for (let tileIndex in tileNames) {\r\n            const tile = tileNames[tileIndex];\r\n            this.tilePieces[tile] = require('./metadata/tiles/' + tile + '.json');\r\n            this.tileSets[tile] = require('./metadata/sets/' + tile + '.json');\r\n        }\r\n    }\r\n    async init(config) {\r\n        console.clear();\r\n        let ctx = this.ctx;\r\n        let canvas = this.canvas;\r\n        this.tileName = config.tileName;\r\n        this.set = config.set;\r\n        this.maxRetryCount = config.maxRetryCount;\r\n        this.maxDepth = config.maxDepth;\r\n        this.tileScaleHeight = config.tileScale;\r\n        this.tileScaleWidth = config.tileScale;\r\n        this.fast = config.fast;\r\n        this.runSpeed = config.runSpeed;\r\n        this.runLoop = config.runLoop;\r\n        this.tilesHeight = config.tilesHeight;\r\n        this.tilesWidth = config.tilesWidth;\r\n        this.superImposed = config.superImposed;\r\n        this.useMouse = config.useMouse;\r\n        this.halfScaleHeight = this.tileScaleHeight / 2;\r\n        this.halfScaleWidth = this.tileScaleWidth / 2;\r\n        canvas.height = this.tilesHeight * this.tileScaleHeight;\r\n        canvas.width = this.tilesWidth * this.tileScaleWidth;\r\n        ctx.fillStyle = \"transparent\";\r\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n        this.loadTiles();\r\n    }\r\n    async initTileData() {\r\n        this.pieces = this.tilePieces[this.tileName];\r\n        this.sets = this.tileSets[this.tileName];\r\n        this.currentSet = this.sets[this.set];\r\n        let loadImagesAsync = this.pieces.map(async (x) => {\r\n            return {\r\n                name: x.name,\r\n                img: await this.preloadImage('tiles/' + this.tileName + '/' + x.imgsrc)\r\n            };\r\n        });\r\n        Object.entries(this.currentSet).forEach((value) => {\r\n            let pieceName = value[0];\r\n            let properties = value[1];\r\n            if (properties.rotations != undefined) {\r\n                this.pieces.find(x => x.name == pieceName).rotations = properties.rotations;\r\n            }\r\n            if (properties.weight != undefined) {\r\n                this.pieces.find(x => x.name == pieceName).weight = properties.weight;\r\n            }\r\n        });\r\n        this.imagesMap = (await Promise.all(loadImagesAsync)).reduce((piecesMap, piece) => {\r\n            piecesMap[piece.name] = piece.img;\r\n            return piecesMap;\r\n        }, {});\r\n        let mappedPieces = this.pieces.reduce((piecesMap, piece) => {\r\n            if (this.currentSet[piece.name] == undefined) {\r\n                return piecesMap;\r\n            }\r\n            let pieceSockets = piece.socket;\r\n            piece.socketmatching = {};\r\n            piece.blacklistedNeighbors = {};\r\n            piece.rotations.forEach((rotation) => {\r\n                let socketMatchObject = {};\r\n                let blacklistedNeighbors = {};\r\n                this.directionsMapIntToKey.forEach((direction, index) => {\r\n                    let rotationMoved = (index - rotation) % this.directionsMapIntToKey.length;\r\n                    if (rotationMoved < 0)\r\n                        rotationMoved += this.directionsMapIntToKey.length;\r\n                    let newRotation = this.directionsMapIntToKey[rotationMoved];\r\n                    let flipped = index >= (this.directionsMapIntToKey.length / 2);\r\n                    let sockets = pieceSockets[newRotation];\r\n                    if (!Array.isArray(sockets)) {\r\n                        sockets = [sockets];\r\n                    }\r\n                    sockets.forEach((socket) => {\r\n                        if (socketMatchObject[direction] == undefined) {\r\n                            socketMatchObject[direction] = [];\r\n                        }\r\n                        if (flipped) {\r\n                            socketMatchObject[direction].push(socket.split(\"\").reverse().join(\"\"));\r\n                        }\r\n                        else {\r\n                            socketMatchObject[direction].push(socket);\r\n                        }\r\n                    });\r\n                });\r\n                if (piece.blacklist) {\r\n                    Object.entries(piece.blacklist).forEach((blacklist) => {\r\n                        let blackListDirection = blacklist[0];\r\n                        let blackListValue = blacklist[1];\r\n                        let blackListIndex = this.directionsMapKeyToInt[blackListDirection];\r\n                        let rotationBlacklistingIndex = (blackListIndex + rotation) % this.directionsMapIntToKey.length;\r\n                        let rotationBlacklisting = this.directionsMapIntToKey[rotationBlacklistingIndex];\r\n                        Object.entries(blackListValue).forEach((blacklistPiece) => {\r\n                            let blackListPieceName = blacklistPiece[0];\r\n                            let blackListPieceRotations = blacklistPiece[1];\r\n                            blackListPieceRotations.forEach((blackListPieceRotation) => {\r\n                                let blackListPieceNameWithRotation = blackListPieceName + \"_\" + (blackListPieceRotation + rotation) % this.directionsMapIntToKey.length;\r\n                                if (blacklistedNeighbors[rotationBlacklisting] == undefined) {\r\n                                    blacklistedNeighbors[rotationBlacklisting] = [];\r\n                                }\r\n                                blacklistedNeighbors[rotationBlacklisting].push(blackListPieceNameWithRotation);\r\n                            });\r\n                        });\r\n                    });\r\n                }\r\n                piece.blacklistedNeighbors[rotation] = blacklistedNeighbors;\r\n                piece.socketmatching[rotation] = socketMatchObject;\r\n            });\r\n            piecesMap[piece.name] = piece;\r\n            return piecesMap;\r\n        }, {});\r\n        let socketBuckets = {};\r\n        Object.entries(mappedPieces).forEach((mappedPieceValue) => {\r\n            let pieceName = mappedPieceValue[0];\r\n            let piece = mappedPieceValue[1];\r\n            if (piece.socketmatching != undefined) {\r\n                Object.entries(piece.socketmatching).forEach((socketMatchValue) => {\r\n                    let socketDirection = parseInt(socketMatchValue[0]);\r\n                    let socketMatch = socketMatchValue[1];\r\n                    Object.entries(socketMatch).forEach((socket) => {\r\n                        let socketDirectionInner = socket[0];\r\n                        let socketMatchInnerValueArray = socket[1];\r\n                        let socketDirectionInnerIndex = this.directionsMapKeyToInt[socketDirectionInner];\r\n                        let socketDirectionPolarIndex = (socketDirectionInnerIndex + this.directionsMapIntToKey.length / 2) % this.directionsMapIntToKey.length;\r\n                        let socketDirectionPolar = this.directionsMapIntToKey[socketDirectionPolarIndex];\r\n                        socketMatchInnerValueArray.forEach((socketMatchInnerValue) => {\r\n                            if (socketBuckets[socketMatchInnerValue] == undefined) {\r\n                                let innerObject = {};\r\n                                socketBuckets[socketMatchInnerValue] = innerObject;\r\n                            }\r\n                            if (socketBuckets[socketMatchInnerValue][socketDirectionPolar] == undefined) {\r\n                                socketBuckets[socketMatchInnerValue][socketDirectionPolar] = [];\r\n                            }\r\n                            socketBuckets[socketMatchInnerValue][socketDirectionPolar].push(pieceName + \"_\" + socketDirection);\r\n                        });\r\n                    });\r\n                });\r\n            }\r\n        });\r\n        this.piecesMap = Object.entries(mappedPieces).reduce((piecesMap, piecePair) => {\r\n            let piece = piecePair[1];\r\n            if (this.currentSet[piece.name] == undefined) {\r\n                return piecesMap;\r\n            }\r\n            if (piece.rotations == undefined) {\r\n                piece.rotations = [0];\r\n            }\r\n            piece.rotations.forEach((rotation) => {\r\n                var _a, _b;\r\n                let pieceName = piece.name + \"_\" + rotation;\r\n                let validNeighbors = {\r\n                    top: [],\r\n                    right: [],\r\n                    bottom: [],\r\n                    left: []\r\n                };\r\n                if (piece.socketmatching != undefined) {\r\n                    if (piece.socketmatching[rotation] != undefined) {\r\n                        let rotationDirection = this.directionsMapIntToKey[rotation];\r\n                        let socketMatch = piece.socketmatching[rotation];\r\n                        Object.entries(socketMatch).forEach((socketPair) => {\r\n                            let socketDirection = socketPair[0];\r\n                            let sockets = socketPair[1];\r\n                            sockets.forEach((socket) => {\r\n                                if (socketBuckets[socket] != undefined && socketBuckets[socket][socketDirection] != undefined) {\r\n                                    let validPiecesForSocket = socketBuckets[socket][socketDirection];\r\n                                    validPiecesForSocket.forEach((validPiece) => {\r\n                                        var _a;\r\n                                        let blackList = (_a = piece.blacklistedNeighbors[rotation][socketDirection]) !== null && _a !== void 0 ? _a : [];\r\n                                        if (!validNeighbors[socketDirection].includes(validPiece) && !blackList.includes(validPiece)) {\r\n                                            validNeighbors[socketDirection].push(validPiece);\r\n                                        }\r\n                                    });\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n                let weight = (_a = piece.weight) !== null && _a !== void 0 ? _a : 1;\r\n                if (Array.isArray(piece.weight)) {\r\n                    weight = (_b = weight[rotation]) !== null && _b !== void 0 ? _b : 1;\r\n                }\r\n                piecesMap[pieceName] = {\r\n                    key: piece.name + \"_\" + rotation,\r\n                    name: piece.name,\r\n                    rotation: rotation,\r\n                    validNeighbors: validNeighbors,\r\n                    newValid: piece.newValid,\r\n                    weight: weight,\r\n                };\r\n            });\r\n            return piecesMap;\r\n        }, {});\r\n        return true;\r\n    }\r\n    initDraw() {\r\n        this.startOver();\r\n        this.startDrawingLoop();\r\n    }\r\n    startOver() {\r\n        this.reset();\r\n        this.startWFCLoop(this.runSpeed);\r\n    }\r\n    reset() {\r\n        //this.ctx.fillStyle = \"black\";\r\n        this.ctx.fillStyle = \"white\";\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n        let piecesKeys = Object.keys(this.piecesMap);\r\n        console.log('this.piecesMap', this.piecesMap);\r\n        let startingTile = {\r\n            validPieces: piecesKeys,\r\n        };\r\n        this.tiles = Array.from({ length: this.tilesWidth }, (a, x) => {\r\n            return Array.from({ length: this.tilesHeight }, (b, y) => {\r\n                return {\r\n                    position: { x: x, y: y },\r\n                    validPieces: [...startingTile.validPieces]\r\n                };\r\n            });\r\n        });\r\n        console.log('this.tiles', this.tiles);\r\n    }\r\n    getTilePositionsAsEntropyGroups() {\r\n        let entropyGroups = {};\r\n        this.tiles.forEach((column, x) => {\r\n            column.forEach((tile, y) => {\r\n                if (tile.validPieces) {\r\n                    let entropy = tile.validPieces.length;\r\n                    if (entropyGroups[entropy] == undefined) {\r\n                        entropyGroups[entropy] = [];\r\n                    }\r\n                    entropyGroups[entropy].push({ x: x, y: y });\r\n                }\r\n            });\r\n        });\r\n        return entropyGroups;\r\n    }\r\n    getRandomElementFromArray(array) {\r\n        return array[Math.floor(Math.random() * array.length)];\r\n    }\r\n    getRandomElementFromArrayWeigted(array) {\r\n        let summed = [];\r\n        let sumCount = 0;\r\n        let lastSum = 0;\r\n        array.forEach((x, i) => {\r\n            let weight = this.piecesMap[x].weight;\r\n            if (weight > 0) {\r\n                lastSum = sumCount;\r\n                sumCount += weight;\r\n                summed.push({\r\n                    'key': x,\r\n                    'minsum': lastSum,\r\n                    'maxsum': sumCount\r\n                });\r\n            }\r\n        });\r\n        if (summed.length == 0)\r\n            return null;\r\n        let rnd = Math.random() * sumCount;\r\n        let selected = summed.find((x) => {\r\n            return x.minsum <= rnd && x.maxsum > rnd;\r\n        });\r\n        if (selected == undefined) {\r\n            console.log('summed', summed);\r\n        }\r\n        return selected.key;\r\n    }\r\n    noValidFound() {\r\n        this.retryCount++;\r\n        this.stopWFCLoop();\r\n        if (this.retryCount <= this.maxRetryCount) {\r\n            this.startOver();\r\n        }\r\n        else {\r\n            console.log('not possible to solve within ' + this.maxRetryCount + ' retries');\r\n        }\r\n    }\r\n    runWFC3() {\r\n        for (var i = 0; (i < this.runLoop) || this.fast; i++) {\r\n            let stop = this.checkForStop();\r\n            if (stop)\r\n                return;\r\n            if (this.stopRunning)\r\n                return;\r\n            let entropyGroups = this.getTilePositionsAsEntropyGroups();\r\n            let entropyKeys = Object.keys(entropyGroups);\r\n            if (entropyKeys.length == 0) {\r\n                this.stopWFCLoop();\r\n                return;\r\n            }\r\n            let lowestEntropyKey = Number(entropyKeys[0]);\r\n            let lowestEntroyGroup = entropyGroups[lowestEntropyKey];\r\n            let randomPositionFromLowestEntropyGroup = this.getRandomElementFromArray(lowestEntroyGroup);\r\n            let x = randomPositionFromLowestEntropyGroup.x;\r\n            let y = randomPositionFromLowestEntropyGroup.y;\r\n            let currentTile = this.tiles[x][y];\r\n            if (currentTile.validPieces != undefined) {\r\n                if (currentTile.validPieces.length == 0) {\r\n                    this.noValidFound();\r\n                    return false;\r\n                }\r\n                let randomPiece = Math.floor(Math.random() * currentTile.validPieces.length);\r\n                let tileKey = this.getRandomElementFromArrayWeigted(currentTile.validPieces);\r\n                if (tileKey == null) {\r\n                    this.noValidFound();\r\n                    return false;\r\n                }\r\n                let piece = this.piecesMap[tileKey];\r\n                this.tiles[x][y] = piece;\r\n                if (piece == undefined) {\r\n                    console.log('piece', x, y, piece, tileKey, randomPiece, currentTile.validPieces);\r\n                }\r\n                let validation = this.runValidation(x, y, [piece]);\r\n                if (validation == null) {\r\n                    break;\r\n                }\r\n                let depth = 0;\r\n                while (validation.length > 0 && depth < this.maxDepth) {\r\n                    let newValidations = [];\r\n                    if (validation.length > 0) {\r\n                        validation.forEach((v) => {\r\n                            let validationTile = this.tiles[v.x][v.y];\r\n                            let validationTilePieces = validationTile.validPieces;\r\n                            let pieces = validationTilePieces.map((tileKey) => {\r\n                                return this.piecesMap[tileKey];\r\n                            });\r\n                            let innerValidation = this.runValidation(v.x, v.y, pieces);\r\n                            newValidations.push(innerValidation);\r\n                        });\r\n                    }\r\n                    let newValidationsConcat = [].concat.apply([], newValidations);\r\n                    let newValidationsSet = Array.from(new Set(newValidationsConcat));\r\n                    depth += 1;\r\n                    validation = newValidationsSet;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    runValidation(x, y, pieces) {\r\n        let recheck = [];\r\n        let neighbors = [];\r\n        if (y != 0) {\r\n            neighbors.push({ direction: 'top', tile: this.tiles[x][y - 1] });\r\n        }\r\n        if (x != this.tilesWidth - 1) {\r\n            neighbors.push({ direction: 'right', tile: this.tiles[x + 1][y] });\r\n        }\r\n        if (y != this.tilesHeight - 1) {\r\n            neighbors.push({ direction: 'bottom', tile: this.tiles[x][y + 1] });\r\n        }\r\n        if (x != 0) {\r\n            neighbors.push({ direction: 'left', tile: this.tiles[x - 1][y] });\r\n        }\r\n        neighbors.forEach((neighbor) => {\r\n            if (neighbor.tile.validPieces) {\r\n                let validBefore = neighbor.tile.validPieces.length;\r\n                let validArray = [];\r\n                pieces.forEach((piece) => {\r\n                    validArray.push(neighbor.tile.validPieces\r\n                        .filter((validPieceToCheck) => {\r\n                        return piece.validNeighbors[neighbor.direction].includes(validPieceToCheck);\r\n                    }));\r\n                });\r\n                let validArrayConcat = [].concat.apply([], validArray);\r\n                let uniquevalidArraySet = Array.from(new Set(validArrayConcat));\r\n                neighbor.tile.validPieces = uniquevalidArraySet;\r\n                var validAfter = neighbor.tile.validPieces.length;\r\n                if (validBefore != validAfter) {\r\n                    recheck.push(neighbor.tile.position);\r\n                }\r\n            }\r\n        });\r\n        return recheck;\r\n    }\r\n    checkForStop() {\r\n        let stop = true;\r\n        this.tiles.forEach((column, columnIndex) => {\r\n            column.forEach((tile, rowIndex) => {\r\n                if (tile.key == undefined) {\r\n                    stop = false;\r\n                    return false;\r\n                }\r\n            });\r\n            if (!stop) {\r\n                return false;\r\n            }\r\n        });\r\n        if (stop) {\r\n            console.log('checkForStop', 'return true');\r\n            console.log('Found solution after ' + this.retryCount + ' retries');\r\n            this.stopWFCLoop();\r\n            return true;\r\n        }\r\n        return stop;\r\n    }\r\n    startWFCLoop(interval) {\r\n        this.stopRunning = false;\r\n        if (this.useMouse) {\r\n            document.body.addEventListener('click', () => this.runWFC3(), true);\r\n        }\r\n        else {\r\n            this.wfcLoop = setInterval(() => {\r\n                this.runWFC3();\r\n            }, interval);\r\n        }\r\n    }\r\n    stopWFCLoop() {\r\n        this.stopRunning = true;\r\n        clearInterval(this.wfcLoop);\r\n    }\r\n    startDrawingLoop() {\r\n        requestAnimationFrame(() => this.draw());\r\n    }\r\n    stopDrawingLoop() {\r\n    }\r\n    draw() {\r\n        this.ctx.save();\r\n        this.drawTiles();\r\n        this.ctx.restore();\r\n        requestAnimationFrame(() => this.draw());\r\n    }\r\n    drawTiles() {\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.tiles.forEach((column, columnIndex) => {\r\n            column.forEach((tile, rowIndex) => {\r\n                if (tile.validPieces) {\r\n                    let validCount = tile.validPieces.length;\r\n                    if (tile.validPieces.length > 0) {\r\n                        if (this.superImposed == SuperImposedState.Layered) {\r\n                            //superimposed 1 - on top of each\r\n                            tile.validPieces.forEach((key) => {\r\n                                let piece = this.piecesMap[key];\r\n                                let tileImage = this.imagesMap[piece.name];\r\n                                this.drawSuperimposed(tileImage, columnIndex, rowIndex, piece.rotation, validCount);\r\n                            });\r\n                        }\r\n                        else if (this.superImposed == SuperImposedState.GridScaled) {\r\n                            //superimposed 2 - grid\r\n                            let gridSize = Math.ceil(Math.sqrt(validCount));\r\n                            tile.validPieces.forEach((key, index) => {\r\n                                let piece = this.piecesMap[key];\r\n                                let tileImage = this.imagesMap[piece.name];\r\n                                this.drawSuperimposedPartGrid(tileImage, columnIndex, rowIndex, gridSize, index, piece.rotation, validCount, 0.4);\r\n                            });\r\n                        }\r\n                        else if (this.superImposed == SuperImposedState.Grid) {\r\n                            //superimposed 3 - grid without scaling\r\n                            validCount = Object.keys(this.piecesMap).length;\r\n                            let gridSize = Math.ceil(Math.sqrt(validCount));\r\n                            tile.validPieces.forEach((key, index) => {\r\n                                let piece = this.piecesMap[key];\r\n                                let tileImage = this.imagesMap[piece.name];\r\n                                this.drawSuperimposedPartGrid(tileImage, columnIndex, rowIndex, gridSize, index, piece.rotation, validCount, 0.4);\r\n                            });\r\n                        }\r\n                        else if (this.superImposed == SuperImposedState.None) {\r\n                            //superimposed 4 - none\r\n                        }\r\n                        else if (this.superImposed == SuperImposedState.LayeredSorted) {\r\n                            //superimposed 5 - layered sorted\r\n                            let sortedValid = tile.validPieces.sort((a, b) => {\r\n                                let pieceA = this.piecesMap[a];\r\n                                let pieceB = this.piecesMap[b];\r\n                                return pieceB.weight - pieceA.weight;\r\n                            });\r\n                            sortedValid.forEach((key) => {\r\n                                let piece = this.piecesMap[key];\r\n                                let tileImage = this.imagesMap[piece.name];\r\n                                this.drawSuperimposed(tileImage, columnIndex, rowIndex, piece.rotation, validCount);\r\n                            });\r\n                        }\r\n                        else if (this.superImposed == SuperImposedState.GridAlpha) {\r\n                            //superimposed 6 - grid scaled alpha\r\n                            let minWeight = 999;\r\n                            let maxWeight = 0;\r\n                            let sortedValid = tile.validPieces.sort((a, b) => {\r\n                                let pieceA = this.piecesMap[a];\r\n                                let pieceB = this.piecesMap[b];\r\n                                let weight = pieceA.weight;\r\n                                if (minWeight > weight) {\r\n                                    minWeight = weight;\r\n                                }\r\n                                if (maxWeight < weight) {\r\n                                    maxWeight = weight;\r\n                                }\r\n                                return pieceB.weight - pieceA.weight;\r\n                            });\r\n                            sortedValid.forEach((key, index) => {\r\n                                let piece = this.piecesMap[key];\r\n                                let tileImage = this.imagesMap[piece.name];\r\n                                let weight = piece.weight;\r\n                                let weightPercent = ((weight - minWeight)) / (maxWeight - minWeight);\r\n                                let adjustedAlpha = (weightPercent * (0.6 - 0.2)) + 0.2;\r\n                                let gridSize = Math.ceil(Math.sqrt(validCount));\r\n                                this.drawSuperimposedPartGrid(tileImage, columnIndex, rowIndex, gridSize, index, piece.rotation, validCount, adjustedAlpha);\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                if (tile.key != undefined) {\r\n                    let key = tile.key;\r\n                    let piece = this.piecesMap[key];\r\n                    let tileImage = this.imagesMap[piece.name];\r\n                    this.drawTile(tileImage, columnIndex, rowIndex, tile.rotation);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    drawImgGrid(img, x, y, rotation, alpha) {\r\n        this.ctx.save();\r\n        this.ctx.globalAlpha = alpha;\r\n        this.ctx.translate((this.tileScaleWidth * x) + this.halfScaleWidth, (this.tileScaleHeight * y) + this.halfScaleHeight);\r\n        this.ctx.rotate((rotation * 90) * (Math.PI / 180));\r\n        this.ctx.drawImage(img, -this.halfScaleWidth, -this.halfScaleHeight, this.tileScaleWidth, this.tileScaleHeight);\r\n        this.ctx.restore();\r\n    }\r\n    drawTile(img, x, y, rotation) {\r\n        this.drawImgGrid(img, x, y, rotation, 1);\r\n    }\r\n    drawSuperimposed(img, x, y, rotation, possible) {\r\n        this.drawImgGrid(img, x, y, rotation, 0.9 / possible);\r\n    }\r\n    drawSuperimposedWeighted(img, x, y, rotation, possible, alpha) {\r\n        this.drawImgGrid(img, x, y, rotation, alpha);\r\n    }\r\n    drawSuperimposedPartGrid(img, x, y, gridSize, gridIndex, rotation, possible, alpha) {\r\n        let width = this.tileScaleWidth / gridSize;\r\n        let height = this.tileScaleHeight / (gridSize);\r\n        let newX = (this.tileScaleWidth * x) + ((gridIndex % gridSize) * width);\r\n        let newY = (this.tileScaleHeight * y) + ((Math.floor(gridIndex / gridSize)) * height);\r\n        this.drawImg(img, newX, newY, width, height, rotation, alpha);\r\n    }\r\n    drawImg(img, x, y, width, height, rotation, alpha) {\r\n        this.ctx.save();\r\n        this.ctx.globalAlpha = alpha;\r\n        this.ctx.translate(x + (width / 2), y + (height / 2));\r\n        this.ctx.rotate((rotation * 90) * (Math.PI / 180));\r\n        this.ctx.drawImage(img, -(width / 2), -(height / 2), width, height);\r\n        this.ctx.restore();\r\n    }\r\n}\r\n","var map = {\n\t\"./Castle.json\": \"./src/metadata/sets/Castle.json\",\n\t\"./Circles.json\": \"./src/metadata/sets/Circles.json\",\n\t\"./Circuit.json\": \"./src/metadata/sets/Circuit.json\",\n\t\"./FloorPlan.json\": \"./src/metadata/sets/FloorPlan.json\",\n\t\"./Knots.json\": \"./src/metadata/sets/Knots.json\",\n\t\"./Rooms.json\": \"./src/metadata/sets/Rooms.json\",\n\t\"./Summer.json\": \"./src/metadata/sets/Summer.json\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/metadata/sets sync recursive ^\\\\.\\\\/.*\\\\.json$\";","var map = {\n\t\"./Castle.json\": \"./src/metadata/tiles/Castle.json\",\n\t\"./Circles.json\": \"./src/metadata/tiles/Circles.json\",\n\t\"./Circuit.json\": \"./src/metadata/tiles/Circuit.json\",\n\t\"./FloorPlan.json\": \"./src/metadata/tiles/FloorPlan.json\",\n\t\"./Knots.json\": \"./src/metadata/tiles/Knots.json\",\n\t\"./Rooms.json\": \"./src/metadata/tiles/Rooms.json\",\n\t\"./Summer.json\": \"./src/metadata/tiles/Summer.json\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/metadata/tiles sync recursive ^\\\\.\\\\/.*\\\\.json$\";","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { WFC } from './wfc';\r\nexport default WFC;\r\nwindow.getWFC = function getWFC(canvasId) {\r\n    return new WFC(canvasId);\r\n};\r\n"],"names":[],"sourceRoot":""}