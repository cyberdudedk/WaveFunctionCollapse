{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;;;;;;;;;;;;;;;;ACR9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;;;;;;;;;;;;;;;;ACRxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACZO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;;;;;;;;;;;;;;;;ACT1B;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB;;;;;;;;;;;;;;;;ACNlB;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;;;;;;;;;;;;;;;;ACNxB;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;;;;;;;;;;;;;;;;ACN9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;;;;;;;;;;;;;;;;ACZxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;;;;;;;;;;;;;;;;;;;;;;;ACPS;AACA;AACV;AACN;AACE;AACI;AACvC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wEAAwB;AACxD;AACA;AACA,4BAA4B,6DAAkB;AAC9C;AACA;AACA;AACA;AACA,yBAAyB,yDAAiB;AAC1C;AACA;AACA,4BAA4B,4DAAiB;AAC7C;AACA;AACO;AACP;AACA,4BAA4B,yEAAyB;AACrD,0BAA0B,wEAA+B;AACzD;AACA;AACA,4BAA4B,6DAAkB;AAC9C;AACA;;;;;;;;;;;;;;;;AC3CO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACLO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACLwD;AACA;AACV;AACW;AACnB;AACE;AACE;AACI;AACvC;AACP;AACA,0BAA0B,iDAAS;AACnC,gCAAgC,uDAAe;AAC/C,uBAAuB,+CAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,2EAAkC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,0EAAiC;AAC1F;AACA,iEAAiE,kBAAkB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAiB;AAChC;AACA;AACA,eAAe,iEAAiB;AAChC;AACA;AACA,eAAe,uDAAY;AAC3B;AACA;AACA,eAAe,iDAAS;AACxB;AACA;AACA,eAAe,mDAAU;AACzB;AACA;AACA,eAAe,uDAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sEAA2B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oEAAyB;AACjE;AACA;AACA;AACA,6CAA6C,qEAA0B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,8EAAQ,IAAoB,0BAA0B,OAAO,CAAC;AACvF;AACA,gDAAgD,6DAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA,4CAA4C,6DAAoB;AAChE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iDAAiD,2EAAkC;AACnF,4CAA4C,0EAAiC;AAC7E;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,wEAA+B,oCAAoC,oEAA2B;AAC1J;AACA;AACA;AACA;AACA;AACA,oDAAoD,wEAA+B;AACnF,oDAAoD,6DAAoB;AACxE,oDAAoD,6DAAoB;AACxE,oDAAoD,0EAAiC;AACrF,oDAAoD,2EAAkC;AACtF;AACA;AACA;AACA;AACA,+EAA+E,wEAA+B;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,4DAA4D;AACjH;AACA,sDAAsD,0DAA0D;AAChH;AACA;AACA;AACA;AACA,gEAAgE,wEAA+B,oCAAoC,oEAA2B;AAC9J;AACA;AACA;AACA;AACA,wDAAwD,wEAA+B;AACvF,wDAAwD,6DAAoB;AAC5E,wDAAwD,6DAAoB;AAC5E,wDAAwD,0EAAiC;AACzF,wDAAwD,2EAAkC;AAC1F;AACA;AACA;AACA,mFAAmF,wEAA+B;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yEAAyB;AAC9C;AACA;AACA,qBAAqB,4EAA4B;AACjD;AACA;AACA,qBAAqB,sEAAsB;AAC3C;AACA;AACA,qBAAqB,+EAA+B;AACpD;AACA;AACA,qBAAqB,2EAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACje8C;AACN;AACgB;AAClB;AACJ;AAC3B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2CAA2C,kDAAkD;AAC7F;AACA,+CAA+C,mDAAmD;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,4DAAiB;AAC7D;AACA;AACA;AACA;AACA,uCAAuC,+CAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8DAAmB;AAC3D;AACA;AACA;AACA,6CAA6C,mEAAwB;AACrE;AACA;AACA;AACA,6CAA6C,4DAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,gDAAW;AACnE,SAAS;AACT;AACA,wDAAwD,yDAAoB;AAC5E,SAAS;AACT;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAQ;AACnC;AACA;AACA;AACA;AACA,iBAAiB,yEAAyB;AAC1C,yBAAyB;AACzB,iBAAiB,2EAA2B;AAC5C,yBAAyB;AACzB,iBAAiB,0EAA0B;AAC3C,yBAAyB;AACzB,iBAAiB,4EAA4B;AAC7C,yBAAyB;AACzB,iBAAiB,qEAAqB;AACtC,yBAAyB;AACzB,iBAAiB,6EAA6B;AAC9C,yBAAyB;AACzB,iBAAiB,4EAA4B;AAC7C,yBAAyB;AACzB,iBAAiB,8EAA8B;AAC/C,yBAAyB;AACzB,iBAAiB,6EAA6B;AAC9C,yBAAyB;AACzB,iBAAiB,wEAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+CAA+C;AACvE;AACA;AACA,mCAAmC,+CAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,wEAAwB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAQ,WAAW,8DAA8D;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,qDAAgB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,2BAA2B,+CAAQ,WAAW,2DAA2D;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,kDAAa;AAChF,oBAAoB;AACpB;AACA,2BAA2B,+CAAQ,WAAW,2DAA2D;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA,8BAA8B;AAC9B,0BAA0B,qDAAgB;AAC1C,+BAA+B,0BAA0B;AACzD;AACA;AACA,+BAA+B,yDAAoB;AACnD,+BAA+B,0BAA0B;AACzD;AACA,+BAA+B,kDAAa;AAC5C,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA,qCAAqC,4FAA4F;AACjI;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA,qCAAqC,+FAA+F;AACpI;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA,qCAAqC,8FAA8F;AACnI;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA,qCAAqC,6FAA6F;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB;AACzD,qCAAqC,wBAAwB;AAC7D;AACA;AACA;AACA;AACA;AACA,6CAA6C,yDAAyD;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4FAA4F;AACzH;AACA;AACA;AACA,6BAA6B,8FAA8F;AAC3H;AACA;AACA;AACA,6BAA6B,+FAA+F;AAC5H;AACA;AACA;AACA,6BAA6B,6FAA6F;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,+CAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+CAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+CAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kDAAkD;AAC7F,+CAA+C,mDAAmD;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,kDAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kDAAkD;AAC7F;AACA,+CAA+C,mDAAmD;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sDAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2DAAmB;AACxD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACvoBwD;AACA;AACV;AACN;AACF;AACE;AACE;AACnC;AACP;AACA,0BAA0B,iDAAS;AACnC,uBAAuB,+CAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAiB;AAChC;AACA;AACA,eAAe,iEAAiB;AAChC;AACA;AACA,eAAe,uDAAY;AAC3B;AACA;AACA,eAAe,iDAAS;AACxB;AACA;AACA,eAAe,mDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sEAA2B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oEAAyB;AACjE;AACA;AACA;AACA,6CAA6C,qEAA0B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,4DAA4D;AACjH;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,0DAA0D;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC/GwC;AACI;AACJ;AACJ;AAC7B;AACP;AACA,2BAA2B,6CAAO;AAClC,0BAA0B,iDAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6CAAO;AAClC;AACA;AACA;AACA;AACA;AACA,4CAA4C,6EAAQ,IAAmB,UAAU,OAAO,CAAC;AACzF,0CAA0C,4EAAQ,IAAkB,UAAU,OAAO,CAAC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,iDAAS;AAChE,yCAAyC,iDAAS;AAClD;AACA,yBAAyB,iDAAS,6BAA6B,iDAAS;AACxE;AACA;AACA,8BAA8B,iDAAS,6BAA6B,iDAAS;AAC7E;AACA;AACA;AACA,+CAA+C,iDAAS;AACxD;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,mDAAmD,iDAAS,CAAC,sDAAc;AAC3E,oDAAoD,iDAAS,CAAC,uDAAe;AAC7E,sCAAsC,iDAAS,CAAC,sDAAc;AAC9D,sCAAsC,iDAAS,CAAC,uDAAe;AAC/D;AACA;AACA;AACA;AACA;AACA,6CAA6C,iDAAS;AACtD,2DAA2D,iDAAS;AACpE,uGAAuG;AACvG,mDAAmD,iDAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,iDAAS;AACjE,2DAA2D,iDAAS;AACpE;AACA,mDAAmD,iDAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iDAAS;AAC3C;AACA;AACA;AACA;AACA,2DAA2D,iDAAS;AACpE;AACA,6BAA6B,iDAAS,6BAA6B,iDAAS;AAC5E;AACA;AACA,kCAAkC,iDAAS,6BAA6B,iDAAS;AACjF;AACA;AACA,+BAA+B,iDAAS;AACxC,qBAAqB;AACrB;AACA,2CAA2C,qDAAW;AACtD,aAAa;AACb;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAI;AAC/B;AACA,aAAa;AACb;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA,kBAAkB;AAClB;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,wCAAwC,eAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UC7BA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;ACNsC;AACE;AACQ;AACR;AACxC;AACA,eAAe,iDAAS;AACxB;AACA;AACA,eAAe,yDAAa;AAC5B;AACA;AACA,eAAe,+CAAQ;AACvB;AACA;AACA,eAAe,iDAAS;AACxB","sources":["webpack://wavefunctioncollapse/./src/Backtracking.ts","webpack://wavefunctioncollapse/./src/Direction.ts","webpack://wavefunctioncollapse/./src/PieceObject.ts","webpack://wavefunctioncollapse/./src/RenderType.ts","webpack://wavefunctioncollapse/./src/Replay.ts","webpack://wavefunctioncollapse/./src/RunMethod.ts","webpack://wavefunctioncollapse/./src/SizingMethod.ts","webpack://wavefunctioncollapse/./src/StartingPositions.ts","webpack://wavefunctioncollapse/./src/SuperImposedState.ts","webpack://wavefunctioncollapse/./src/WFCConfig.ts","webpack://wavefunctioncollapse/./src/WFCData.ts","webpack://wavefunctioncollapse/./src/WFCEvent.ts","webpack://wavefunctioncollapse/./src/WFCRender.ts","webpack://wavefunctioncollapse/./src/WFCRunner.ts","webpack://wavefunctioncollapse/./src/WFCTextRender.ts","webpack://wavefunctioncollapse/./src/WFCTiles.ts","webpack://wavefunctioncollapse/./src/metadata/render/ sync ^\\.\\/.*\\.json$","webpack://wavefunctioncollapse/./src/metadata/sets/ sync ^\\.\\/.*\\.json$","webpack://wavefunctioncollapse/./src/metadata/tiles/ sync ^\\.\\/.*\\.json$","webpack://wavefunctioncollapse/webpack/bootstrap","webpack://wavefunctioncollapse/webpack/runtime/define property getters","webpack://wavefunctioncollapse/webpack/runtime/hasOwnProperty shorthand","webpack://wavefunctioncollapse/webpack/runtime/make namespace object","webpack://wavefunctioncollapse/./src/index.ts"],"sourcesContent":["export var Backtracking;\r\n(function (Backtracking) {\r\n    Backtracking[Backtracking[\"None\"] = 0] = \"None\";\r\n    Backtracking[Backtracking[\"Full\"] = 1] = \"Full\";\r\n    Backtracking[Backtracking[\"Linear\"] = 2] = \"Linear\";\r\n    Backtracking[Backtracking[\"Exponential\"] = 3] = \"Exponential\";\r\n    //Grid,\r\n    //Combination\r\n})(Backtracking || (Backtracking = {}));\r\n","export var Direction;\r\n(function (Direction) {\r\n    Direction[Direction[\"top\"] = 0] = \"top\";\r\n    Direction[Direction[\"right\"] = 1] = \"right\";\r\n    Direction[Direction[\"grid\"] = 2] = \"grid\";\r\n    Direction[Direction[\"bottom\"] = 3] = \"bottom\";\r\n    Direction[Direction[\"left\"] = 4] = \"left\";\r\n    Direction[Direction[\"grid2\"] = 5] = \"grid2\";\r\n})(Direction || (Direction = {}));\r\n","export class PieceObject {\r\n    constructor(key, name, rotation, validNeighbors, edgeblacklist, weight, sockets, minimum = null, maximum = null) {\r\n        this.key = key;\r\n        this.name = name;\r\n        this.rotation = rotation;\r\n        this.validNeighbors = validNeighbors;\r\n        this.edgeblacklist = edgeblacklist;\r\n        this.weight = weight;\r\n        this.sockets = sockets;\r\n        this.minimum = minimum;\r\n        this.maximum = maximum;\r\n    }\r\n}\r\n","export var RenderType;\r\n(function (RenderType) {\r\n    RenderType[RenderType[\"None\"] = 0] = \"None\";\r\n    RenderType[RenderType[\"TilesAndSuperImposed\"] = 1] = \"TilesAndSuperImposed\";\r\n    RenderType[RenderType[\"TilesOnly\"] = 2] = \"TilesOnly\";\r\n    RenderType[RenderType[\"SuperImposedOnly\"] = 3] = \"SuperImposedOnly\";\r\n    RenderType[RenderType[\"ColorOnly\"] = 4] = \"ColorOnly\";\r\n    RenderType[RenderType[\"PixelBasedColorDominant\"] = 5] = \"PixelBasedColorDominant\";\r\n    RenderType[RenderType[\"PixelBasedColorAverage\"] = 6] = \"PixelBasedColorAverage\";\r\n})(RenderType || (RenderType = {}));\r\n","export var Replay;\r\n(function (Replay) {\r\n    Replay[Replay[\"None\"] = 0] = \"None\";\r\n    Replay[Replay[\"Backtrack\"] = 1] = \"Backtrack\";\r\n    Replay[Replay[\"Preset\"] = 2] = \"Preset\";\r\n    Replay[Replay[\"BacktrackOnly\"] = 3] = \"BacktrackOnly\";\r\n})(Replay || (Replay = {}));\r\n","export var RunMethod;\r\n(function (RunMethod) {\r\n    RunMethod[RunMethod[\"AutoRun\"] = 0] = \"AutoRun\";\r\n    RunMethod[RunMethod[\"AutoStart\"] = 1] = \"AutoStart\";\r\n    RunMethod[RunMethod[\"Step\"] = 2] = \"Step\";\r\n    RunMethod[RunMethod[\"UntilExpand\"] = 3] = \"UntilExpand\";\r\n})(RunMethod || (RunMethod = {}));\r\n","export var SizingMethod;\r\n(function (SizingMethod) {\r\n    SizingMethod[SizingMethod[\"Fixed\"] = 0] = \"Fixed\";\r\n    SizingMethod[SizingMethod[\"CalcCanvasSize\"] = 1] = \"CalcCanvasSize\";\r\n    SizingMethod[SizingMethod[\"CalcTileSize\"] = 2] = \"CalcTileSize\";\r\n    SizingMethod[SizingMethod[\"CalcTileScale\"] = 3] = \"CalcTileScale\";\r\n})(SizingMethod || (SizingMethod = {}));\r\n","export var StartingPositions;\r\n(function (StartingPositions) {\r\n    StartingPositions[StartingPositions[\"Random\"] = 0] = \"Random\";\r\n    StartingPositions[StartingPositions[\"TopLeft\"] = 1] = \"TopLeft\";\r\n    StartingPositions[StartingPositions[\"TopCenter\"] = 2] = \"TopCenter\";\r\n    StartingPositions[StartingPositions[\"TopRight\"] = 3] = \"TopRight\";\r\n    StartingPositions[StartingPositions[\"CenterLeft\"] = 4] = \"CenterLeft\";\r\n    StartingPositions[StartingPositions[\"Mid\"] = 5] = \"Mid\";\r\n    StartingPositions[StartingPositions[\"CenterRight\"] = 6] = \"CenterRight\";\r\n    StartingPositions[StartingPositions[\"BottomLeft\"] = 7] = \"BottomLeft\";\r\n    StartingPositions[StartingPositions[\"BottomCenter\"] = 8] = \"BottomCenter\";\r\n    StartingPositions[StartingPositions[\"BottomRight\"] = 9] = \"BottomRight\";\r\n})(StartingPositions || (StartingPositions = {}));\r\n","export var SuperImposedState;\r\n(function (SuperImposedState) {\r\n    SuperImposedState[SuperImposedState[\"Layered\"] = 0] = \"Layered\";\r\n    SuperImposedState[SuperImposedState[\"LayeredSorted\"] = 1] = \"LayeredSorted\";\r\n    SuperImposedState[SuperImposedState[\"Grid\"] = 2] = \"Grid\";\r\n    SuperImposedState[SuperImposedState[\"GridScaled\"] = 3] = \"GridScaled\";\r\n    SuperImposedState[SuperImposedState[\"GridAlpha\"] = 4] = \"GridAlpha\";\r\n})(SuperImposedState || (SuperImposedState = {}));\r\n","import { StartingPositions } from \"./StartingPositions\";\r\nimport { SuperImposedState } from \"./SuperImposedState\";\r\nimport { SizingMethod } from \"./SizingMethod\";\r\nimport { RunMethod } from \"./RunMethod\";\r\nimport { RenderType } from \"./RenderType\";\r\nimport { Backtracking } from \"./Backtracking\";\r\nexport class WFCConfig {\r\n    constructor() {\r\n        this.maxRetryCount = 10;\r\n        this.maxDepth = 100;\r\n        this.tileScale = 40;\r\n        this.fast = false;\r\n        this.runSpeed = 10;\r\n        this.runLoop = 30;\r\n        this.tilesHeight = 30;\r\n        this.tilesWidth = 30;\r\n        this.useMouse = false;\r\n        this.edgeWrapAround = false;\r\n        this.edgeSocket = \"\";\r\n        this.tileName = 'Knots';\r\n        this.set = 'all';\r\n        this.startingPosition = StartingPositions.Random;\r\n        this.canvasHeight = 450;\r\n        this.canvasWidth = 450;\r\n        this.sizingMethod = SizingMethod.Fixed;\r\n        this.offsetX = 0;\r\n        this.offsetY = 0;\r\n        this.autoExpandSize = 1;\r\n        this.autoExpand = false;\r\n        this.runMethod = RunMethod.AutoRun;\r\n        this.neighborDistance = 1;\r\n        this.gridSize = 0;\r\n        this.backtracking = Backtracking.None;\r\n    }\r\n}\r\nexport class WFCRenderConfig {\r\n    constructor() {\r\n        this.superImposed = SuperImposedState.Layered;\r\n        this.renderType = RenderType.TilesAndSuperImposed;\r\n        this.canvasHeight = 450;\r\n        this.canvasWidth = 450;\r\n        this.sizingMethod = SizingMethod.Fixed;\r\n    }\r\n}\r\n","export class WFCData {\r\n    constructor() {\r\n        this.tileSets = {};\r\n        this.tilePieces = {};\r\n    }\r\n}\r\n","export class WFCEvent {\r\n    constructor(type, data = null) {\r\n        this.type = type;\r\n        this.data = data;\r\n    }\r\n}\r\n","import { SuperImposedState } from './SuperImposedState';\r\nimport { StartingPositions } from './StartingPositions';\r\nimport { SizingMethod } from './SizingMethod';\r\nimport { WFCConfig, WFCRenderConfig } from './WFCConfig';\r\nimport { WFCTiles } from './WFCTiles';\r\nimport { RunMethod } from './RunMethod';\r\nimport { RenderType } from './RenderType';\r\nimport { Backtracking } from './Backtracking';\r\nexport class WFCRender {\r\n    constructor(canvasId) {\r\n        this.config = new WFCConfig();\r\n        this.renderConfig = new WFCRenderConfig();\r\n        this.wfc = new WFCTiles();\r\n        this.halfScaleHeight = this.config.tileScale / 2;\r\n        this.halfScaleWidth = this.config.tileScale / 2;\r\n        this.imagesMap = {};\r\n        this.wfcCallback = (event) => {\r\n            if (event.type != 'step' &&\r\n                event.type != \"found\" &&\r\n                event.type != \"stopped\" &&\r\n                event.type != \"reset\") {\r\n                //console.log('event', event.type, event.data);\r\n            }\r\n            if (event.type == 'step') {\r\n                this.draw(event.data.affectedTiles);\r\n            }\r\n            else if (event.type == 'reset') {\r\n                this.startOver();\r\n            }\r\n            else {\r\n                this.draw();\r\n            }\r\n            return true;\r\n        };\r\n        this.canvas = document.getElementById(canvasId);\r\n        this.ctx = this.canvas.getContext(\"2d\");\r\n    }\r\n    preloadImage(src) {\r\n        return new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = (event) => resolve(image);\r\n            image.onerror = (event) => reject();\r\n            image.src = src;\r\n            return image;\r\n        });\r\n    }\r\n    preloadColorImage(color) {\r\n        return new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            var canvas = document.createElement('canvas');\r\n            var ctx = canvas.getContext(\"2d\");\r\n            canvas.width = 10;\r\n            canvas.height = 10;\r\n            ctx.fillStyle = color;\r\n            ctx.fillRect(0, 0, 10, 10);\r\n            image.src = canvas.toDataURL();\r\n            resolve(image);\r\n        });\r\n    }\r\n    preloadPixelColorImage(src) {\r\n        return new Promise((resolve, reject) => {\r\n            const image = new Image();\r\n            image.onload = (event) => {\r\n                const colorImage = new Image();\r\n                const canvas = document.createElement('canvas');\r\n                const ctx = canvas.getContext(\"2d\");\r\n                const colorCanvas = document.createElement('canvas');\r\n                const colorCtx = colorCanvas.getContext(\"2d\");\r\n                let r = 0;\r\n                let g = 0;\r\n                let b = 0;\r\n                if (this.renderConfig.renderType == RenderType.PixelBasedColorDominant) {\r\n                    ctx.imageSmoothingEnabled = true;\r\n                    ctx.drawImage(image, 0, 0, 1, 1);\r\n                    const dominantColor = ctx.getImageData(0, 0, 1, 1).data.slice(0, 3);\r\n                    r = dominantColor[0];\r\n                    g = dominantColor[1];\r\n                    b = dominantColor[2];\r\n                }\r\n                else if (this.renderConfig.renderType == RenderType.PixelBasedColorAverage) {\r\n                    var blockSize = 5, // only visit every 5 pixels\r\n                    data, width, height, i = -4, length, rgb = { r: 0, g: 0, b: 0 }, count = 0;\r\n                    height = canvas.height = image.naturalHeight || image.offsetHeight || image.height;\r\n                    width = canvas.width = image.naturalWidth || image.offsetWidth || image.width;\r\n                    ctx.drawImage(image, 0, 0);\r\n                    data = ctx.getImageData(0, 0, width, height);\r\n                    length = data.data.length;\r\n                    while ((i += blockSize * 4) < length) {\r\n                        ++count;\r\n                        rgb.r += data.data[i];\r\n                        rgb.g += data.data[i + 1];\r\n                        rgb.b += data.data[i + 2];\r\n                    }\r\n                    // ~~ used to floor values\r\n                    r = ~~(rgb.r / count);\r\n                    g = ~~(rgb.g / count);\r\n                    b = ~~(rgb.b / count);\r\n                }\r\n                colorCanvas.width = 10;\r\n                colorCanvas.height = 10;\r\n                colorCtx.fillStyle = \"rgba(\" + r + \", \" + g + \", \" + b + \", 1)\";\r\n                colorCtx.fillRect(0, 0, 10, 10);\r\n                colorImage.src = colorCanvas.toDataURL();\r\n                resolve(colorImage);\r\n            };\r\n            image.onerror = (event) => reject();\r\n            image.src = src;\r\n        });\r\n    }\r\n    getAvailableTiles() {\r\n        return Object.keys(this.wfc.wfcData.tileSets);\r\n    }\r\n    getSuperImposedStates() {\r\n        return SuperImposedState;\r\n    }\r\n    getStartingPositions() {\r\n        return StartingPositions;\r\n    }\r\n    getSizingMethods() {\r\n        return SizingMethod;\r\n    }\r\n    getRunMethods() {\r\n        return RunMethod;\r\n    }\r\n    getRenderTypes() {\r\n        return RenderType;\r\n    }\r\n    getBacktrackingMethods() {\r\n        return Backtracking;\r\n    }\r\n    getAvailableSets(tileName) {\r\n        var sets = this.wfc.wfcData.tileSets[tileName];\r\n        if (sets == null)\r\n            return null;\r\n        return Object.keys(sets);\r\n    }\r\n    getTileSets() {\r\n        return this.wfc.wfcData.tileSets;\r\n    }\r\n    async init(config, renderConfig, wfc, wfcRunner) {\r\n        this.config = config;\r\n        this.renderConfig = renderConfig;\r\n        this.resizeCanvas();\r\n        this.ctx.fillStyle = \"transparent\";\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.wfc = wfc;\r\n        this.wfcRunner = wfcRunner;\r\n        this.wfcRunner.addCallback(this.wfcCallback);\r\n    }\r\n    resizeCanvas() {\r\n        if (this.config.sizingMethod == SizingMethod.CalcCanvasSize) {\r\n            this.canvas.height = this.config.tilesHeight * this.config.tileScale;\r\n            this.canvas.width = this.config.tilesWidth * this.config.tileScale;\r\n        }\r\n        else {\r\n            this.canvas.height = this.config.canvasHeight;\r\n            this.canvas.width = this.config.canvasWidth;\r\n        }\r\n        //TODO: Move this check to the config\r\n        if (this.config.sizingMethod == SizingMethod.CalcTileSize) {\r\n            this.config.tilesHeight = Math.floor(this.config.canvasHeight / this.config.tileScale);\r\n            this.config.tilesWidth = Math.floor(this.config.canvasWidth / this.config.tileScale);\r\n        }\r\n        else if (this.config.sizingMethod == SizingMethod.CalcTileScale) {\r\n            this.config.tileScale = Math.max(Math.floor(this.config.canvasHeight) / this.config.tilesHeight, Math.floor(this.config.canvasWidth / this.config.tilesWidth));\r\n        }\r\n        this.halfScaleHeight = this.config.tileScale / 2;\r\n        this.halfScaleWidth = this.config.tileScale / 2;\r\n    }\r\n    async initImageData() {\r\n        let pieces = this.wfc.wfcData.tilePieces[this.config.tileName];\r\n        let tileImages = require('./metadata/render/' + this.config.tileName + '.json');\r\n        let tileImageMap = tileImages.reduce((tileMap, tileImage) => {\r\n            if (this.renderConfig.renderType == RenderType.ColorOnly) {\r\n                tileMap[tileImage.name] = tileImage.color;\r\n            }\r\n            else {\r\n                tileMap[tileImage.name] = tileImage.imgsrc;\r\n            }\r\n            return tileMap;\r\n        }, {});\r\n        let loadImagesAsync = [];\r\n        if (this.renderConfig.renderType == RenderType.ColorOnly) {\r\n            loadImagesAsync = pieces.map(async (x) => {\r\n                return {\r\n                    name: x.name,\r\n                    img: await this.preloadColorImage(tileImageMap[x.name])\r\n                };\r\n            });\r\n        }\r\n        else if (this.renderConfig.renderType == RenderType.PixelBasedColorDominant ||\r\n            this.renderConfig.renderType == RenderType.PixelBasedColorAverage) {\r\n            loadImagesAsync = pieces.map(async (x) => {\r\n                return {\r\n                    name: x.name,\r\n                    img: await this.preloadPixelColorImage('tiles/' + this.config.tileName + '/' + tileImageMap[x.name])\r\n                };\r\n            });\r\n        }\r\n        else {\r\n            loadImagesAsync = pieces.map(async (x) => {\r\n                return {\r\n                    name: x.name,\r\n                    img: await this.preloadImage('tiles/' + this.config.tileName + '/' + tileImageMap[x.name])\r\n                };\r\n            });\r\n        }\r\n        this.imagesMap = (await Promise.all(loadImagesAsync)).reduce((piecesMap, piece) => {\r\n            piecesMap[piece.name] = piece.img;\r\n            return piecesMap;\r\n        }, {});\r\n    }\r\n    initDraw() {\r\n        this.startOver();\r\n    }\r\n    startOver() {\r\n        this.reset();\r\n        this.startWFCLoop(this.config.runSpeed);\r\n    }\r\n    expand() {\r\n        this.resizeCanvas();\r\n        this.draw();\r\n    }\r\n    reset() {\r\n        this.ctx.fillStyle = \"white\";\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n    getCursorPosition(event) {\r\n        const rect = this.canvas.getBoundingClientRect();\r\n        const x = event.clientX - rect.left;\r\n        const y = event.clientY - rect.top;\r\n        return { x, y };\r\n    }\r\n    canvasClicked(event) {\r\n        event.button == 2;\r\n        let position = this.getCursorPosition(event);\r\n        let tileX = Math.floor(position.x / this.config.tileScale) - this.config.offsetX;\r\n        let tileY = Math.floor(position.y / this.config.tileScale) - this.config.offsetY;\r\n        if (event.button == 0) {\r\n            this.wfcRunner.cycleTile(tileX, tileY);\r\n            this.draw();\r\n        }\r\n        else if (event.button == 2) {\r\n            this.wfcRunner.placeCycledTile(tileX, tileY);\r\n            this.draw();\r\n        }\r\n    }\r\n    startWFCLoop(interval) {\r\n        if (this.config.useMouse) {\r\n            this.canvas.addEventListener('click', (e) => {\r\n                this.canvasClicked(e);\r\n            });\r\n            this.canvas.addEventListener('contextmenu', (e) => {\r\n                this.canvasClicked(e);\r\n                if (e.preventDefault != undefined)\r\n                    e.preventDefault();\r\n                if (e.stopPropagation != undefined)\r\n                    e.stopPropagation();\r\n                return false;\r\n            });\r\n        }\r\n        this.draw();\r\n        this.wfcRunner.start(interval);\r\n    }\r\n    draw(tiles = undefined) {\r\n        this.ctx.save();\r\n        if (tiles != undefined) {\r\n            this.drawTiles(tiles);\r\n        }\r\n        else {\r\n            this.drawAllTiles();\r\n        }\r\n        this.ctx.restore();\r\n    }\r\n    drawTiles(positions) {\r\n        for (let pos of positions) {\r\n            let columnIndex = pos.x;\r\n            let rowIndex = pos.y;\r\n            let column = this.wfc.tiles[columnIndex];\r\n            let tile = column[rowIndex];\r\n            if (tile) {\r\n                if (!this.config.fast) {\r\n                    if (tile.validPieces) {\r\n                        if (this.renderConfig.renderType == RenderType.TilesAndSuperImposed || this.renderConfig.renderType == RenderType.SuperImposedOnly) {\r\n                            this.clearTile(columnIndex, rowIndex);\r\n                            this.drawSuperImposed(columnIndex, rowIndex, tile);\r\n                        }\r\n                    }\r\n                }\r\n                if (this.renderConfig.renderType == RenderType.TilesAndSuperImposed ||\r\n                    this.renderConfig.renderType == RenderType.TilesOnly ||\r\n                    this.renderConfig.renderType == RenderType.ColorOnly ||\r\n                    this.renderConfig.renderType == RenderType.PixelBasedColorAverage ||\r\n                    this.renderConfig.renderType == RenderType.PixelBasedColorDominant) {\r\n                    if (tile.key != undefined) {\r\n                        this.clearTile(columnIndex, rowIndex);\r\n                        this.drawTile(this.imagesMap[this.wfc.piecesMap[tile.key].name], columnIndex, rowIndex, tile.rotation);\r\n                    }\r\n                    else if (tile.temporary && this.renderConfig.renderType == RenderType.TilesAndSuperImposed) {\r\n                        this.clearTile(columnIndex, rowIndex);\r\n                        this.drawTile(this.imagesMap[this.wfc.piecesMap[tile.temporary.key].name], columnIndex, rowIndex, tile.temporary.rotation, 0.8);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    drawAllTiles() {\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        for (let columnIndex = -this.config.offsetX; columnIndex < this.config.tilesWidth - this.config.offsetX; columnIndex++) {\r\n            let column = this.wfc.tiles[columnIndex];\r\n            for (let rowIndex = -this.config.offsetY; rowIndex < this.config.tilesHeight - this.config.offsetY; rowIndex++) {\r\n                let tile = column[rowIndex];\r\n                if (tile) {\r\n                    if (!this.config.fast) {\r\n                        if (tile.validPieces) {\r\n                            if (this.renderConfig.renderType == RenderType.TilesAndSuperImposed || this.renderConfig.renderType == RenderType.SuperImposedOnly) {\r\n                                this.drawSuperImposed(columnIndex, rowIndex, tile);\r\n                            }\r\n                        }\r\n                    }\r\n                    if (this.renderConfig.renderType == RenderType.TilesAndSuperImposed ||\r\n                        this.renderConfig.renderType == RenderType.TilesOnly ||\r\n                        this.renderConfig.renderType == RenderType.ColorOnly ||\r\n                        this.renderConfig.renderType == RenderType.PixelBasedColorAverage ||\r\n                        this.renderConfig.renderType == RenderType.PixelBasedColorDominant) {\r\n                        if (tile.key != undefined) {\r\n                            this.drawTile(this.imagesMap[this.wfc.piecesMap[tile.key].name], columnIndex, rowIndex, tile.rotation);\r\n                        }\r\n                        else if (tile.temporary && this.renderConfig.renderType == RenderType.TilesAndSuperImposed) {\r\n                            this.drawTile(this.imagesMap[this.wfc.piecesMap[tile.temporary.key].name], columnIndex, rowIndex, tile.temporary.rotation, 0.8);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    drawSuperImposed(columnIndex, rowIndex, tile) {\r\n        if (tile.key != undefined)\r\n            return;\r\n        let validCount = tile.validPieces.length;\r\n        if (validCount > 0) {\r\n            switch (this.renderConfig.superImposed) {\r\n                case SuperImposedState.Layered:\r\n                    this.drawSuperImposed_Layered(columnIndex, rowIndex, tile, validCount);\r\n                    break;\r\n                case SuperImposedState.GridScaled:\r\n                    this.drawSuperImposed_GridScaled(columnIndex, rowIndex, tile, validCount);\r\n                    break;\r\n                case SuperImposedState.Grid:\r\n                    this.drawSuperImposed_Grid(columnIndex, rowIndex, tile, validCount);\r\n                    break;\r\n                case SuperImposedState.LayeredSorted:\r\n                    this.drawSuperImposed_LayeredSorted(columnIndex, rowIndex, tile, validCount);\r\n                    break;\r\n                case SuperImposedState.GridAlpha:\r\n                    this.drawSuperImposed_GridAlpha(columnIndex, rowIndex, tile, validCount);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    drawSuperImposed_Layered(columnIndex, rowIndex, tile, validCount) {\r\n        tile.validPieces.forEach((key) => {\r\n            let piece = this.wfc.piecesMap[key];\r\n            let tileImage = this.imagesMap[piece.name];\r\n            this.drawSuperimposed(tileImage, columnIndex, rowIndex, piece.rotation, validCount);\r\n        });\r\n    }\r\n    drawSuperImposed_LayeredSorted(columnIndex, rowIndex, tile, validCount) {\r\n        let sortedValid = tile.validPieces.sort((a, b) => {\r\n            let pieceA = this.wfc.piecesMap[a];\r\n            let pieceB = this.wfc.piecesMap[b];\r\n            return pieceB.weight - pieceA.weight;\r\n        });\r\n        sortedValid.forEach((key) => {\r\n            let piece = this.wfc.piecesMap[key];\r\n            let tileImage = this.imagesMap[piece.name];\r\n            this.drawSuperimposed(tileImage, columnIndex, rowIndex, piece.rotation, validCount);\r\n        });\r\n    }\r\n    drawSuperImposed_GridScaled(columnIndex, rowIndex, tile, validCount) {\r\n        let gridSize = Math.ceil(Math.sqrt(validCount));\r\n        tile.validPieces.forEach((key, index) => {\r\n            let piece = this.wfc.piecesMap[key];\r\n            let tileImage = this.imagesMap[piece.name];\r\n            this.drawSuperimposedPartGrid(tileImage, columnIndex, rowIndex, gridSize, index, piece.rotation, validCount, 0.4);\r\n        });\r\n    }\r\n    drawSuperImposed_Grid(columnIndex, rowIndex, tile, validCount) {\r\n        let piecesCount = Object.keys(this.wfc.piecesMap).length;\r\n        let gridSize = Math.ceil(Math.sqrt(piecesCount));\r\n        let minWeight = 999;\r\n        let maxWeight = 0;\r\n        let sortedValid = tile.validPieces.sort((a, b) => {\r\n            let pieceA = this.wfc.piecesMap[a];\r\n            let pieceB = this.wfc.piecesMap[b];\r\n            let weight = pieceA.weight;\r\n            if (minWeight > weight) {\r\n                minWeight = weight;\r\n            }\r\n            if (maxWeight < weight) {\r\n                maxWeight = weight;\r\n            }\r\n            if (pieceA.weight == pieceB.weight) {\r\n                return a.localeCompare(b);\r\n            }\r\n            return pieceB.weight - pieceA.weight;\r\n        });\r\n        sortedValid.forEach((key, index) => {\r\n            let piece = this.wfc.piecesMap[key];\r\n            let tileImage = this.imagesMap[piece.name];\r\n            this.drawSuperimposedPartGrid(tileImage, columnIndex, rowIndex, gridSize, index, piece.rotation, piecesCount, 0.4);\r\n        });\r\n    }\r\n    drawSuperImposed_GridAlpha(columnIndex, rowIndex, tile, validCount) {\r\n        let minWeight = 999;\r\n        let maxWeight = 0;\r\n        let sortedValid = tile.validPieces.sort((a, b) => {\r\n            let pieceA = this.wfc.piecesMap[a];\r\n            let pieceB = this.wfc.piecesMap[b];\r\n            let weight = pieceA.weight;\r\n            if (minWeight > weight) {\r\n                minWeight = weight;\r\n            }\r\n            if (maxWeight < weight) {\r\n                maxWeight = weight;\r\n            }\r\n            if (pieceA.weight == pieceB.weight) {\r\n                return a.localeCompare(b);\r\n            }\r\n            return pieceB.weight - pieceA.weight;\r\n        });\r\n        sortedValid.forEach((key, index) => {\r\n            let piece = this.wfc.piecesMap[key];\r\n            let tileImage = this.imagesMap[piece.name];\r\n            let weight = piece.weight;\r\n            let weightPercent = ((weight - minWeight)) / (maxWeight - minWeight);\r\n            let adjustedAlpha = (weightPercent * (0.6 - 0.2)) + 0.2;\r\n            let gridSize = Math.ceil(Math.sqrt(validCount));\r\n            this.drawSuperimposedPartGrid(tileImage, columnIndex, rowIndex, gridSize, index, piece.rotation, validCount, adjustedAlpha);\r\n        });\r\n    }\r\n    drawImgGrid(img, x, y, rotation, alpha) {\r\n        this.ctx.save();\r\n        this.ctx.globalAlpha = alpha;\r\n        this.ctx.translate((this.config.tileScale * (x + this.config.offsetX)) + this.halfScaleWidth, (this.config.tileScale * (y + this.config.offsetY)) + this.halfScaleHeight);\r\n        this.ctx.rotate((rotation * 90) * (Math.PI / 180));\r\n        this.ctx.drawImage(img, -this.halfScaleWidth, -this.halfScaleHeight, this.config.tileScale, this.config.tileScale);\r\n        this.ctx.restore();\r\n    }\r\n    clearTile(x, y) {\r\n        this.ctx.clearRect((this.config.tileScale * (x + this.config.offsetX)), (this.config.tileScale * (y + this.config.offsetY)), this.config.tileScale, this.config.tileScale);\r\n    }\r\n    drawTile(img, x, y, rotation, alpha = 1) {\r\n        this.drawImgGrid(img, x, y, rotation, alpha);\r\n    }\r\n    drawSuperimposed(img, x, y, rotation, possible) {\r\n        this.drawImgGrid(img, x, y, rotation, 0.9 / possible);\r\n    }\r\n    drawSuperimposedWeighted(img, x, y, rotation, possible, alpha) {\r\n        this.drawImgGrid(img, x, y, rotation, alpha);\r\n    }\r\n    drawSuperimposedPartGrid(img, x, y, gridSize, gridIndex, rotation, possible, alpha) {\r\n        let width = this.config.tileScale / gridSize;\r\n        let height = this.config.tileScale / (gridSize);\r\n        let newX = (this.config.tileScale * (x + this.config.offsetX))\r\n            + ((gridIndex % gridSize) * width);\r\n        let newY = (this.config.tileScale * (y + this.config.offsetY))\r\n            + ((Math.floor(gridIndex / gridSize)) * height);\r\n        this.drawImg(img, newX, newY, width, height, rotation, alpha);\r\n    }\r\n    drawImg(img, x, y, width, height, rotation, alpha) {\r\n        this.ctx.save();\r\n        this.ctx.globalAlpha = alpha;\r\n        this.ctx.translate(x + (width / 2), y + (height / 2));\r\n        this.ctx.rotate((rotation * 90) * (Math.PI / 180));\r\n        this.ctx.drawImage(img, -(width / 2), -(height / 2), width, height);\r\n        this.ctx.restore();\r\n    }\r\n    getImage() {\r\n        return this.canvas.toDataURL(\"image/png\");\r\n    }\r\n}\r\n","import { Backtracking } from './Backtracking';\r\nimport { RunMethod } from './RunMethod';\r\nimport { StartingPositions } from './StartingPositions';\r\nimport { WFCEvent } from './WFCEvent';\r\nimport { Replay } from './Replay';\r\nexport class WFCRunner {\r\n    constructor(config, wfc) {\r\n        this.retryCount = 0;\r\n        this.stopRunning = true;\r\n        this.wfcLoop = undefined;\r\n        this.callbacks = [];\r\n        this.pickFirstTile = true;\r\n        this.placedTiles = 0;\r\n        this.lastPosition = undefined;\r\n        this.replay = [];\r\n        this.replayPreset = [];\r\n        this.hasRunWFC = (event) => {\r\n            let results = this.callbacks.map((callback) => {\r\n                return callback(event);\r\n            });\r\n            return results.every(Boolean);\r\n        };\r\n        this.entropyGroupsPositions = {};\r\n        this.entropyPositions = {};\r\n        this.config = config;\r\n        this.wfc = wfc;\r\n        this.backtrackingSelections = [];\r\n    }\r\n    addCallback(callback) {\r\n        this.callbacks.push(callback);\r\n    }\r\n    expand() {\r\n        this.config.tilesHeight += this.config.autoExpandSize * 2;\r\n        this.config.tilesWidth += this.config.autoExpandSize * 2;\r\n        this.config.offsetX += this.config.autoExpandSize * 1;\r\n        this.config.offsetY += this.config.autoExpandSize * 1;\r\n        let newCells = this.wfc.expand();\r\n        newCells.forEach((cell) => {\r\n            let placedNeighbors = this.runValidation(cell.x, cell.y, [], true);\r\n            if (placedNeighbors.length > 0) {\r\n                placedNeighbors.forEach((position) => {\r\n                    let piece = this.wfc.tiles[position.x][position.y];\r\n                    this.runValidationLoop(position.x, position.y, [piece]);\r\n                });\r\n            }\r\n        });\r\n        //this.recalculateEntropyGroups();\r\n    }\r\n    getTilePositionsAsEntropyGroups() {\r\n        let entropyGroups = {};\r\n        for (let x = -this.config.offsetX; x < this.config.tilesWidth - this.config.offsetX; x++) {\r\n            let column = this.wfc.tiles[x];\r\n            for (let y = -this.config.offsetY; y < this.config.tilesHeight - this.config.offsetY; y++) {\r\n                let tile = column[y];\r\n                if (tile.key == undefined) {\r\n                    let entropy = tile.validPieces.length;\r\n                    if (entropyGroups[entropy] == undefined) {\r\n                        entropyGroups[entropy] = [];\r\n                    }\r\n                    entropyGroups[entropy].push({ x: x, y: y });\r\n                }\r\n            }\r\n        }\r\n        return entropyGroups;\r\n    }\r\n    noValidFound() {\r\n        this.retryCount++;\r\n        this.stopWFCLoop();\r\n        if (this.retryCount <= this.config.maxRetryCount) {\r\n            if (this.config.backtracking != Backtracking.None) {\r\n                this.backtrack();\r\n            }\r\n            else {\r\n                if (!this.config.fast) {\r\n                    this.hasRunWFC(new WFCEvent('retry'));\r\n                }\r\n                this.reset();\r\n                this.startWFCLoop(this.config.runSpeed);\r\n            }\r\n        }\r\n        else {\r\n            console.log('not possible to solve within ' + this.config.maxRetryCount + ' retries');\r\n            //this.hasRunWFC(new WFCEvent('unsolvable'));\r\n        }\r\n    }\r\n    backtrack() {\r\n        var slicedReplay = [];\r\n        var lastReplay = undefined;\r\n        var restReplays = [];\r\n        if (this.config.backtracking == Backtracking.Linear) {\r\n            slicedReplay = this.replay.slice(0, -this.retryCount);\r\n            restReplays = this.replay.slice(-this.retryCount);\r\n        }\r\n        else if (this.config.backtracking == Backtracking.Exponential) {\r\n            slicedReplay = this.replay.slice(0, -(this.retryCount * this.retryCount));\r\n            restReplays = this.replay.slice(-(this.retryCount * this.retryCount));\r\n        }\r\n        else if (this.config.backtracking == Backtracking.Full) {\r\n            slicedReplay = this.replay.slice(0, -1);\r\n            restReplays = this.replay.slice(-1);\r\n        }\r\n        this.replay = [];\r\n        this.reset(false, false);\r\n        this.replayPreset.forEach((value, index, array) => {\r\n            this.placeTile(value.x, value.y, value.key, Replay.None);\r\n        });\r\n        slicedReplay.forEach((value, index, array) => {\r\n            this.placeTile(value.x, value.y, value.key, Replay.BacktrackOnly);\r\n        });\r\n        lastReplay = restReplays[0];\r\n        for (var i = 1; i < restReplays.length; i++) {\r\n            delete this.backtrackingSelections[restReplays[i].x][restReplays[i].y];\r\n        }\r\n        if (lastReplay != undefined) {\r\n            let lastReplayBackTrackingSelection = this.backtrackingSelections[lastReplay.x][lastReplay.y];\r\n            let lastReplayTile = this.wfc.tiles[lastReplay.x][lastReplay.y];\r\n            const lastReplayBackTrackingSelectionToRemove = new Set(lastReplayBackTrackingSelection);\r\n            this.wfc.tiles[lastReplay.x][lastReplay.y].validPieces =\r\n                this.wfc.tiles[lastReplay.x][lastReplay.y].validPieces\r\n                    .filter((x) => !lastReplayBackTrackingSelectionToRemove.has(x));\r\n            if (lastReplayTile.validPieces.length == 0) {\r\n                delete this.backtrackingSelections[lastReplay.x][lastReplay.y];\r\n                this.backtrack();\r\n                return;\r\n            }\r\n        }\r\n        this.hasRunWFC(new WFCEvent('backtracked'));\r\n        this.continueRun();\r\n    }\r\n    pickPosition(position) {\r\n        switch (position) {\r\n            case StartingPositions.TopLeft:\r\n                return { x: -this.config.offsetX, y: -this.config.offsetY };\r\n            case StartingPositions.TopCenter:\r\n                return { x: Math.floor(this.config.tilesWidth / 2) - this.config.offsetX, y: -this.config.offsetY };\r\n            case StartingPositions.TopRight:\r\n                return { x: this.config.tilesWidth - this.config.offsetX - 1, y: -this.config.offsetY };\r\n            case StartingPositions.CenterLeft:\r\n                return { x: -this.config.offsetX, y: Math.floor(this.config.tilesHeight / 2) - this.config.offsetY };\r\n            case StartingPositions.Mid:\r\n                return { x: Math.floor(this.config.tilesWidth / 2) - this.config.offsetX, y: Math.floor(this.config.tilesHeight / 2) - this.config.offsetY };\r\n            case StartingPositions.CenterRight:\r\n                return { x: this.config.tilesWidth - this.config.offsetX - 1, y: Math.floor(this.config.tilesHeight / 2) - this.config.offsetY };\r\n            case StartingPositions.BottomLeft:\r\n                return { x: -this.config.offsetX, y: this.config.tilesHeight - this.config.offsetY - 1 };\r\n            case StartingPositions.BottomCenter:\r\n                return { x: Math.floor(this.config.tilesWidth / 2) - this.config.offsetX, y: this.config.tilesHeight - this.config.offsetY - 1 };\r\n            case StartingPositions.BottomRight:\r\n                return { x: this.config.tilesWidth - this.config.offsetX - 1, y: this.config.tilesHeight - this.config.offsetY - 1 };\r\n            case StartingPositions.Random:\r\n                let entropyGroups = this.entropyGroupsPositions;\r\n                let entropyKeys = Object.keys(entropyGroups);\r\n                if (entropyKeys.length == 0) {\r\n                    return null;\r\n                }\r\n                let lowestEntropyKey = Number(entropyKeys[0]);\r\n                let lowestEntroyGroup = entropyGroups[lowestEntropyKey];\r\n                let lowestEntropyGroupPositions = Object.keys(lowestEntroyGroup);\r\n                let randomKeyFromLowestEntropyGroup = this.getRandomElementFromArray(lowestEntropyGroupPositions);\r\n                let randomPositionFromLowestEntropyGroup = lowestEntroyGroup[randomKeyFromLowestEntropyGroup];\r\n                return randomPositionFromLowestEntropyGroup;\r\n        }\r\n    }\r\n    runWFC() {\r\n        let pickedPos = [];\r\n        let allAffectedTiles = [];\r\n        for (var i = 0; (i < this.config.runLoop) || this.config.fast; i++) {\r\n            let stop = this.checkForStop();\r\n            if (stop) {\r\n                this.hasRunWFC(new WFCEvent('stop'));\r\n                return;\r\n            }\r\n            if (this.stopRunning)\r\n                return;\r\n            let pos = null;\r\n            if (this.pickFirstTile) {\r\n                pos = this.pickPosition(this.config.startingPosition);\r\n                this.pickFirstTile = false;\r\n            }\r\n            else {\r\n                pos = this.pickPosition(StartingPositions.Random);\r\n            }\r\n            if (pos == null) {\r\n                console.log('noposition found stopping');\r\n                this.stopWFCLoop();\r\n                return;\r\n            }\r\n            let placed = this.placeTilePosition(pos.x, pos.y);\r\n            if (placed == false) {\r\n                break;\r\n            }\r\n            pickedPos.push(pos);\r\n            if (placed != undefined && placed !== true) {\r\n                allAffectedTiles = allAffectedTiles.concat(placed);\r\n            }\r\n        }\r\n        if (!this.config.fast) {\r\n            let allAffectedTilesSet = Array.from(new Set(allAffectedTiles));\r\n            this.hasRunWFC(new WFCEvent('step', { 'pickedPos': pickedPos, 'affectedTiles': allAffectedTilesSet }));\r\n        }\r\n    }\r\n    placeTilePosition(x, y) {\r\n        let currentTile = this.wfc.tiles[x][y];\r\n        if (currentTile.validPieces != undefined) {\r\n            if (currentTile.validPieces.length == 0) {\r\n                this.noValidFound();\r\n                return false;\r\n            }\r\n            let tileKey = this.getRandomElementFromArrayWeigted(currentTile.validPieces);\r\n            if (tileKey == null) {\r\n                this.noValidFound();\r\n                return false;\r\n            }\r\n            let affectedTiles = this.placeTile(x, y, tileKey, Replay.Backtrack);\r\n            if (affectedTiles == null) {\r\n                return false;\r\n            }\r\n            return affectedTiles;\r\n        }\r\n        console.log('reached end of placetileposition, validpieces is undefined', currentTile, currentTile.validPieces);\r\n    }\r\n    cycleTile(x, y) {\r\n        let currentTile = this.wfc.tiles[x][y];\r\n        if (currentTile.validPieces == undefined || currentTile.validPieces.length == 0) {\r\n            return;\r\n        }\r\n        if (currentTile.cycle == undefined) {\r\n            currentTile.cycle = 0;\r\n        }\r\n        else {\r\n            currentTile.cycle += 1;\r\n        }\r\n        currentTile.cycle = currentTile.cycle % currentTile.validPieces.length;\r\n        let tileKey = currentTile.validPieces[currentTile.cycle];\r\n        let piece = this.wfc.piecesMap[tileKey];\r\n        currentTile.temporary = piece;\r\n        let pos = { x: x, y: y };\r\n        let pickedPos = [pos];\r\n        let allAffectedTiles = [pos];\r\n        this.hasRunWFC(new WFCEvent('step', { 'pickedPos': pickedPos, 'affectedTiles': allAffectedTiles }));\r\n    }\r\n    placeCycledTile(x, y) {\r\n        let currentTile = this.wfc.tiles[x][y];\r\n        if (currentTile.temporary == undefined) {\r\n            return;\r\n        }\r\n        let temporary = currentTile.temporary;\r\n        currentTile.temporary = undefined;\r\n        let allAffectedTiles = this.placeTile(x, y, temporary.key, Replay.Preset);\r\n        let pos = { x: x, y: y };\r\n        let pickedPos = [pos];\r\n        this.hasRunWFC(new WFCEvent('step', { 'pickedPos': pickedPos, 'affectedTiles': allAffectedTiles }));\r\n    }\r\n    addBacktrackingSelection(x, y, key) {\r\n        if (this.backtrackingSelections[x] == undefined) {\r\n            this.backtrackingSelections[x] = [];\r\n        }\r\n        if (this.backtrackingSelections[x][y] == undefined) {\r\n            this.backtrackingSelections[x][y] = [];\r\n        }\r\n        this.backtrackingSelections[x][y].push(key);\r\n    }\r\n    placeTile(x, y, tileKey, replayType) {\r\n        let piece = this.wfc.piecesMap[tileKey];\r\n        this.wfc.tiles[x][y] = Object.assign(this.wfc.tiles[x][y], piece);\r\n        this.recalculateEntropyGroup(x, y);\r\n        let affectedTiles = this.runValidationLoop(x, y, [piece]);\r\n        if (affectedTiles == null) {\r\n            affectedTiles = [{ x: x, y: y }];\r\n        }\r\n        else {\r\n            affectedTiles.push({ x: x, y: y });\r\n        }\r\n        this.wfc.tileCounters[piece.name].count += 1;\r\n        this.wfc.tiles[x][y].pickedFrom = this.lastPosition;\r\n        this.lastPosition = { x: x, y: y };\r\n        if (replayType == Replay.Backtrack) {\r\n            this.replay.push({ x: x, y: y, key: tileKey });\r\n            this.addBacktrackingSelection(x, y, tileKey);\r\n        }\r\n        else if (replayType == Replay.BacktrackOnly) {\r\n            this.replay.push({ x: x, y: y, key: tileKey });\r\n        }\r\n        else if (replayType == Replay.Preset) {\r\n            this.replayPreset.push({ x: x, y: y, key: tileKey });\r\n        }\r\n        this.checkForMaximumTiles(piece.name);\r\n        this.placedTiles += 1;\r\n        return affectedTiles;\r\n    }\r\n    runValidationLoop(x, y, pieces) {\r\n        let validation = this.runValidation(x, y, pieces);\r\n        let runValidationLoopPosititions = validation;\r\n        if (validation == null) {\r\n            return null;\r\n        }\r\n        let depth = 0;\r\n        while (validation.length > 0 && depth < this.config.maxDepth) {\r\n            let newValidations = [];\r\n            if (validation.length > 0) {\r\n                validation.forEach((v) => {\r\n                    let innerValidation = this.validatePosition(v.x, v.y);\r\n                    newValidations.push(innerValidation);\r\n                });\r\n            }\r\n            let newValidationsConcat = [].concat.apply([], newValidations);\r\n            let newValidationsSet = Array.from(new Set(newValidationsConcat));\r\n            depth += 1;\r\n            validation = newValidationsSet;\r\n            runValidationLoopPosititions = runValidationLoopPosititions.concat(newValidationsSet);\r\n        }\r\n        let runValidationLoopPosititionsSet = Array.from(new Set(runValidationLoopPosititions));\r\n        return runValidationLoopPosititionsSet;\r\n    }\r\n    validatePosition(x, y) {\r\n        let validationTile = this.wfc.tiles[x][y];\r\n        let validationTilePieces = validationTile.validPieces;\r\n        let pieces = validationTilePieces.map((tileKey) => {\r\n            return this.wfc.piecesMap[tileKey];\r\n        });\r\n        let innerValidation = this.runValidation(x, y, pieces);\r\n        return innerValidation;\r\n    }\r\n    getNeighbors(x, y, count) {\r\n        let neighbors = [];\r\n        if (this.config.edgeWrapAround || y != -this.config.offsetY) {\r\n            for (let index = 0; index > -count; index--) {\r\n                let offsettedNeighborY = this.config.edgeWrapAround ?\r\n                    ((y + this.config.offsetY + index - 1 + this.config.tilesHeight) % this.config.tilesHeight) - this.config.offsetY :\r\n                    y + index - 1;\r\n                if (offsettedNeighborY >= -this.config.offsetY) {\r\n                    neighbors.push({ direction: 'top', tile: this.wfc.tiles[x][offsettedNeighborY], x: x, y: offsettedNeighborY });\r\n                }\r\n            }\r\n        }\r\n        if (this.config.edgeWrapAround || y != this.config.tilesHeight - this.config.offsetY - 1) {\r\n            for (let index = 0; index < count; index++) {\r\n                let offsettedNeighborY = this.config.edgeWrapAround ?\r\n                    ((y + this.config.offsetY + index + 1 + this.config.tilesHeight) % this.config.tilesHeight) - this.config.offsetY :\r\n                    y + index + 1;\r\n                if (offsettedNeighborY <= this.config.tilesHeight - this.config.offsetY - 1) {\r\n                    neighbors.push({ direction: 'bottom', tile: this.wfc.tiles[x][offsettedNeighborY], x: x, y: offsettedNeighborY });\r\n                }\r\n            }\r\n        }\r\n        if (this.config.edgeWrapAround || x != this.config.tilesWidth - this.config.offsetX - 1) {\r\n            for (let index = 0; index < count; index++) {\r\n                let offsettedNeighborX = this.config.edgeWrapAround ?\r\n                    ((x + this.config.offsetX + index + 1 + this.config.tilesWidth) % this.config.tilesWidth) - this.config.offsetX :\r\n                    x + index + 1;\r\n                if (offsettedNeighborX <= this.config.tilesWidth - this.config.offsetX - 1) {\r\n                    neighbors.push({ direction: 'right', tile: this.wfc.tiles[offsettedNeighborX][y], x: offsettedNeighborX, y: y });\r\n                }\r\n            }\r\n        }\r\n        if (this.config.edgeWrapAround || x != -this.config.offsetX) {\r\n            for (let index = 0; index > -count; index--) {\r\n                let offsettedNeighborX = this.config.edgeWrapAround ?\r\n                    ((x + this.config.offsetX + index - 1 + this.config.tilesWidth) % this.config.tilesWidth) - this.config.offsetX :\r\n                    x + index - 1;\r\n                if (offsettedNeighborX >= -this.config.offsetX) {\r\n                    neighbors.push({ direction: 'left', tile: this.wfc.tiles[offsettedNeighborX][y], x: offsettedNeighborX, y: y });\r\n                }\r\n            }\r\n        }\r\n        return neighbors;\r\n    }\r\n    getNeighbors_grid(x, y, xGrid, yGrid) {\r\n        let neighbors = [];\r\n        let offsettedX = x;\r\n        let offsettedY = y;\r\n        let fromX = Math.floor(offsettedX / xGrid) * xGrid;\r\n        let fromY = Math.floor(offsettedY / yGrid) * yGrid;\r\n        for (let indexX = fromX; indexX < fromX + xGrid; indexX++) {\r\n            for (let indexY = fromY; indexY < fromY + yGrid; indexY++) {\r\n                let columns = this.wfc.tiles[indexX];\r\n                if (columns != undefined) {\r\n                    let neighbor = columns[indexY];\r\n                    if (neighbor != undefined) {\r\n                        if (neighbor.position.x != x || neighbor.position.y != y) {\r\n                            neighbors.push({ direction: 'grid', tile: neighbor, x: indexX, y: indexY });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return neighbors;\r\n    }\r\n    getNeighbors_normal(x, y) {\r\n        let neighbors = [];\r\n        if (this.config.edgeWrapAround || y != -this.config.offsetY) {\r\n            let offsettedNeighborY = ((y + this.config.offsetY - 1 + this.config.tilesHeight) % this.config.tilesHeight) - this.config.offsetY;\r\n            neighbors.push({ direction: 'top', tile: this.wfc.tiles[x][offsettedNeighborY], x: x, y: offsettedNeighborY });\r\n        }\r\n        if (this.config.edgeWrapAround || x != this.config.tilesWidth - this.config.offsetX - 1) {\r\n            let offsettedNeighborX = ((x + this.config.offsetX + 1 + this.config.tilesWidth) % this.config.tilesWidth) - this.config.offsetX;\r\n            neighbors.push({ direction: 'right', tile: this.wfc.tiles[offsettedNeighborX][y], x: offsettedNeighborX, y: y });\r\n        }\r\n        if (this.config.edgeWrapAround || y != this.config.tilesHeight - this.config.offsetY - 1) {\r\n            let offsettedNeighborY = ((y + this.config.offsetY + 1 + this.config.tilesHeight) % this.config.tilesHeight) - this.config.offsetY;\r\n            neighbors.push({ direction: 'bottom', tile: this.wfc.tiles[x][offsettedNeighborY], x: x, y: offsettedNeighborY });\r\n        }\r\n        if (this.config.edgeWrapAround || x != -this.config.offsetX) {\r\n            let offsettedNeighborX = ((x + this.config.offsetX - 1 + this.config.tilesWidth) % this.config.tilesWidth) - this.config.offsetX;\r\n            neighbors.push({ direction: 'left', tile: this.wfc.tiles[offsettedNeighborX][y], x: offsettedNeighborX, y: y });\r\n        }\r\n        return neighbors;\r\n    }\r\n    runValidation(x, y, pieces, getPlaced = false) {\r\n        let recheck = [];\r\n        let neighbors = [];\r\n        neighbors = neighbors.concat(this.getNeighbors(x, y, this.config.neighborDistance));\r\n        if (this.config.gridSize > 0) {\r\n            neighbors = neighbors.concat(this.getNeighbors_grid(x, y, this.config.gridSize, this.config.gridSize));\r\n        }\r\n        neighbors.forEach((neighbor) => {\r\n            if (!getPlaced && neighbor.tile.validPieces) {\r\n                let validBefore = neighbor.tile.validPieces.length;\r\n                let validArray = [];\r\n                pieces.forEach((piece) => {\r\n                    validArray.push(neighbor.tile.validPieces\r\n                        .filter((validPieceToCheck) => {\r\n                        var _a;\r\n                        return (_a = piece.validNeighbors[neighbor.direction]) === null || _a === void 0 ? void 0 : _a.includes(validPieceToCheck);\r\n                    }));\r\n                });\r\n                let validArrayConcat = [].concat.apply([], validArray);\r\n                let uniquevalidArraySet = Array.from(new Set(validArrayConcat));\r\n                neighbor.tile.validPieces = uniquevalidArraySet;\r\n                if (neighbor.tile.temporary != undefined) {\r\n                    if (!neighbor.tile.validPieces.includes(neighbor.tile.temporary.key)) {\r\n                        neighbor.tile.temporary = undefined;\r\n                    }\r\n                }\r\n                var validAfter = neighbor.tile.validPieces.length;\r\n                if (validBefore != validAfter) {\r\n                    recheck.push(neighbor.tile.position);\r\n                    this.recalculateEntropyGroup(neighbor.tile.position.x, neighbor.tile.position.y);\r\n                }\r\n            }\r\n            else if (getPlaced && (neighbor.tile.key != undefined)) {\r\n                recheck.push({\r\n                    x: neighbor.x,\r\n                    y: neighbor.y\r\n                });\r\n            }\r\n        });\r\n        return recheck;\r\n    }\r\n    checkForStop() {\r\n        var _a;\r\n        let stop = this.placedTiles >= this.config.tilesWidth * this.config.tilesHeight;\r\n        if (stop) {\r\n            console.log('Found solution after ' + this.retryCount + ' retries');\r\n            let continueRun = (_a = this.hasRunWFC(new WFCEvent('found'))) !== null && _a !== void 0 ? _a : false;\r\n            if (!continueRun) {\r\n                console.log('stopWFCLoop');\r\n                this.stopWFCLoop();\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        return stop;\r\n    }\r\n    stopWFCLoop() {\r\n        this.stopRunning = true;\r\n        clearInterval(this.wfcLoop);\r\n        this.hasRunWFC(new WFCEvent('stopped'));\r\n    }\r\n    reset(refresh = true, setStartTiles = true) {\r\n        this.wfc.reset();\r\n        if (setStartTiles)\r\n            this.setStartTiles();\r\n        this.pickFirstTile = true;\r\n        this.placedTiles = 0;\r\n        if (refresh)\r\n            this.hasRunWFC(new WFCEvent('reset'));\r\n        this.recalculateEntropyGroups();\r\n    }\r\n    recalculateEntropyGroup(x, y) {\r\n        let tile = this.wfc.tiles[x][y];\r\n        let positionKey = x + ',' + y;\r\n        let sameEntropy = false;\r\n        let oldEntropy = this.entropyPositions[positionKey];\r\n        if (tile.key == undefined) {\r\n            let entropy = tile.validPieces.length;\r\n            if (this.entropyGroupsPositions[entropy] == undefined) {\r\n                this.entropyGroupsPositions[entropy] = {};\r\n            }\r\n            this.entropyGroupsPositions[entropy][positionKey] = { x: x, y: y };\r\n            this.entropyPositions[positionKey] = entropy;\r\n            if (oldEntropy && oldEntropy == entropy) {\r\n                sameEntropy = true;\r\n            }\r\n        }\r\n        else {\r\n            delete this.entropyPositions[positionKey];\r\n        }\r\n        if (oldEntropy != undefined && sameEntropy == false) {\r\n            if (this.entropyGroupsPositions[oldEntropy] != undefined) {\r\n                if (this.entropyGroupsPositions[oldEntropy][positionKey] != undefined) {\r\n                    delete this.entropyGroupsPositions[oldEntropy][positionKey];\r\n                }\r\n                if (this.entropyGroupsPositions[oldEntropy] != undefined && Object.keys(this.entropyGroupsPositions[oldEntropy]).length == 0) {\r\n                    delete this.entropyGroupsPositions[oldEntropy];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    recalculateEntropyGroups() {\r\n        for (let x = -this.config.offsetX; x < this.config.tilesWidth - this.config.offsetX; x++) {\r\n            for (let y = -this.config.offsetY; y < this.config.tilesHeight - this.config.offsetY; y++) {\r\n                this.recalculateEntropyGroup(x, y);\r\n            }\r\n        }\r\n    }\r\n    setStartTiles() {\r\n        //console.log('this.wfc.piecesMap', this.wfc.piecesMap);\r\n        let failed = false;\r\n        Object.entries(this.wfc.tileCounters).forEach((values) => {\r\n            if (failed)\r\n                return;\r\n            let tileCounterKey = values[0];\r\n            let countObject = values[1];\r\n            if (countObject.minimum != undefined && countObject.minimum > 0) {\r\n                let maxTrySet = countObject.minimum * 10;\r\n                let trySet = 0;\r\n                while (countObject.count < countObject.minimum && trySet < maxTrySet) {\r\n                    trySet++;\r\n                    let x = Math.floor(Math.random() * this.config.tilesWidth);\r\n                    let y = Math.floor(Math.random() * this.config.tilesHeight);\r\n                    let tile = this.wfc.tiles[x][y];\r\n                    let tilePieces = tile.validPieces;\r\n                    if (tile.validPieces == undefined)\r\n                        continue;\r\n                    if (tile.validPieces.length == 0)\r\n                        continue;\r\n                    let counterTiles = tilePieces.filter((tileKey) => this.wfc.piecesMap[tileKey].name == tileCounterKey);\r\n                    if (counterTiles.length > 0) {\r\n                        let randomIndex = Math.floor(Math.random() * counterTiles.length);\r\n                        let placeTileKey = counterTiles[randomIndex];\r\n                        let placed = this.placeTile(x, y, placeTileKey, Replay.Preset);\r\n                        if (!placed) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                if (countObject.count < countObject.minimum) {\r\n                    failed = true;\r\n                }\r\n            }\r\n        });\r\n        if (failed) {\r\n            this.noValidFound();\r\n        }\r\n        else {\r\n            this.checkForMaximumTilesReached();\r\n        }\r\n    }\r\n    checkForMaximumTilesReached() {\r\n        Object.entries(this.wfc.tileCounters).forEach((values) => {\r\n            let tileCounterKey = values[0];\r\n            this.checkForMaximumTiles(tileCounterKey);\r\n        });\r\n    }\r\n    checkForMaximumTiles(tileName) {\r\n        var countObject = this.wfc.tileCounters[tileName];\r\n        if (countObject.maximum != undefined) {\r\n            if (countObject.count >= countObject.maximum) {\r\n                this.maximumReached(tileName);\r\n            }\r\n        }\r\n    }\r\n    maximumReached(tileName) {\r\n        let pieceObjectsForRemoval = Object.entries(this.wfc.piecesMap)\r\n            .filter((values) => values[1].name == tileName)\r\n            .map((values) => values[0]);\r\n        for (let x = -this.config.offsetX; x < this.config.tilesWidth - this.config.offsetX; x++) {\r\n            let column = this.wfc.tiles[x];\r\n            for (let y = -this.config.offsetY; y < this.config.tilesHeight - this.config.offsetY; y++) {\r\n                let tile = column[y];\r\n                if (tile.validPieces) {\r\n                    tile.validPieces = tile.validPieces.filter((tileKey) => !pieceObjectsForRemoval.includes(tileKey));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    start(interval) {\r\n        this.startWFCLoop(interval);\r\n    }\r\n    continueRun() {\r\n        this.stopRunning = false;\r\n        if (this.config.runMethod == RunMethod.Step) {\r\n            this.runWFC();\r\n        }\r\n        else {\r\n            if (this.config.fast == true) {\r\n                this.runWFC();\r\n            }\r\n            else {\r\n                this.wfcLoop = setInterval(() => {\r\n                    this.runWFC();\r\n                }, this.config.runSpeed);\r\n            }\r\n        }\r\n    }\r\n    startWFCLoop(interval) {\r\n        this.stopWFCLoop();\r\n        this.stopRunning = false;\r\n        if (this.config.runMethod == RunMethod.AutoStart) {\r\n            this.wfcLoop = setInterval(() => {\r\n                this.runWFC();\r\n            }, interval);\r\n        }\r\n    }\r\n    getRandomElementFromArray(array) {\r\n        return array[Math.floor(Math.random() * array.length)];\r\n    }\r\n    getRandomElementFromArrayWeigted(array) {\r\n        let summed = [];\r\n        let sumCount = 0;\r\n        let lastSum = 0;\r\n        array.forEach((x, i) => {\r\n            let weight = this.wfc.piecesMap[x].weight;\r\n            if (weight > 0) {\r\n                lastSum = sumCount;\r\n                sumCount += weight;\r\n                summed.push({\r\n                    'key': x,\r\n                    'minsum': lastSum,\r\n                    'maxsum': sumCount\r\n                });\r\n            }\r\n        });\r\n        if (summed.length == 0)\r\n            return null;\r\n        let rnd = Math.random() * sumCount;\r\n        let selected = summed.find((x) => {\r\n            return x.minsum <= rnd && x.maxsum > rnd;\r\n        });\r\n        if (selected == undefined) {\r\n            console.log('summed', summed);\r\n        }\r\n        return selected.key;\r\n    }\r\n}\r\n","import { SuperImposedState } from './SuperImposedState';\r\nimport { StartingPositions } from './StartingPositions';\r\nimport { SizingMethod } from './SizingMethod';\r\nimport { WFCConfig } from './WFCConfig';\r\nimport { WFCTiles } from './WFCTiles';\r\nimport { RunMethod } from './RunMethod';\r\nimport { RenderType } from './RenderType';\r\nexport class WFCTextRender {\r\n    constructor(canvasId) {\r\n        this.config = new WFCConfig();\r\n        this.wfc = new WFCTiles();\r\n        this.wfcCallback = (event) => {\r\n            if (event.type != 'step' &&\r\n                event.type != \"found\" &&\r\n                event.type != \"stopped\" &&\r\n                event.type != \"reset\") {\r\n                //console.log('event', event.type, event.data);\r\n            }\r\n            if (event.type == 'step') {\r\n                this.draw(event.data.affectedTiles);\r\n            }\r\n            else if (event.type == 'reset') {\r\n            }\r\n            else {\r\n                this.draw();\r\n            }\r\n            return true;\r\n        };\r\n        this.textField = document.getElementById(canvasId);\r\n    }\r\n    getAvailableTiles() {\r\n        return Object.keys(this.wfc.wfcData.tileSets);\r\n    }\r\n    getSuperImposedStates() {\r\n        return SuperImposedState;\r\n    }\r\n    getStartingPositions() {\r\n        return StartingPositions;\r\n    }\r\n    getSizingMethods() {\r\n        return SizingMethod;\r\n    }\r\n    getRunMethods() {\r\n        return RunMethod;\r\n    }\r\n    getRenderTypes() {\r\n        return RenderType;\r\n    }\r\n    getAvailableSets(tileName) {\r\n        var sets = this.wfc.wfcData.tileSets[tileName];\r\n        if (sets == null)\r\n            return null;\r\n        return Object.keys(sets);\r\n    }\r\n    getTileSets() {\r\n        return this.wfc.wfcData.tileSets;\r\n    }\r\n    async init(config, wfc, wfcRunner) {\r\n        this.config = config;\r\n        this.resizeCanvas();\r\n        this.wfc = wfc;\r\n        this.wfcRunner = wfcRunner;\r\n        this.wfcRunner.addCallback(this.wfcCallback);\r\n    }\r\n    resizeCanvas() {\r\n        if (this.config.sizingMethod == SizingMethod.CalcCanvasSize) {\r\n            this.textField.style.height = (this.config.tilesHeight * this.config.tileScale) + \"px\";\r\n            this.textField.style.width = this.config.tilesWidth * this.config.tileScale + \"px\";\r\n        }\r\n        else {\r\n            this.textField.style.height = this.config.canvasHeight + \"px\";\r\n            this.textField.style.width = this.config.canvasWidth + \"px\";\r\n        }\r\n        //TODO: Move this check to the config\r\n        if (this.config.sizingMethod == SizingMethod.CalcTileSize) {\r\n            this.config.tilesHeight = Math.floor(this.config.canvasHeight / this.config.tileScale);\r\n            this.config.tilesWidth = Math.floor(this.config.canvasWidth / this.config.tileScale);\r\n        }\r\n        else if (this.config.sizingMethod == SizingMethod.CalcTileScale) {\r\n            this.config.tileScale = Math.max(Math.floor(this.config.canvasHeight) / this.config.tilesHeight, Math.floor(this.config.canvasWidth / this.config.tilesWidth));\r\n        }\r\n    }\r\n    expand() {\r\n        this.resizeCanvas();\r\n        this.draw();\r\n    }\r\n    draw(tiles = undefined) {\r\n        this.drawAllTiles();\r\n    }\r\n    drawAllTiles() {\r\n        let result = [];\r\n        for (let columnIndex = -this.config.offsetX; columnIndex < this.config.tilesWidth - this.config.offsetX; columnIndex++) {\r\n            let columIndexPos = columnIndex + this.config.offsetX;\r\n            if (result[columIndexPos] == undefined) {\r\n                let row = [];\r\n                result[columIndexPos] = row;\r\n            }\r\n            let column = this.wfc.tiles[columnIndex];\r\n            for (let rowIndex = -this.config.offsetY; rowIndex < this.config.tilesHeight - this.config.offsetY; rowIndex++) {\r\n                let tile = column[rowIndex];\r\n                if (tile) {\r\n                    if (tile.key != undefined) {\r\n                        let tileStr = tile.key;\r\n                        result[columIndexPos].push(tileStr);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let jsonStr = JSON.stringify(result, null, 2);\r\n        this.textField.innerHTML = \"<pre>\" + jsonStr + \"</pre>\";\r\n    }\r\n}\r\n","import { Direction } from './Direction';\r\nimport { PieceObject } from './PieceObject';\r\nimport { WFCConfig } from './WFCConfig';\r\nimport { WFCData } from './WFCData';\r\nexport class WFCTiles {\r\n    constructor() {\r\n        this.wfcData = new WFCData();\r\n        this.config = new WFCConfig();\r\n        this.piecesMap = {};\r\n        this.tiles = [];\r\n        this.tileCounters = {};\r\n        this.minX = 0;\r\n        this.minY = 0;\r\n        this.maxX = 0;\r\n        this.maxY = 0;\r\n    }\r\n    async init(config) {\r\n        //console.clear();\r\n        this.config = config;\r\n        this.config.offsetX = 0;\r\n        this.config.offsetY = 0;\r\n        this.minX = 0;\r\n        this.minY = 0;\r\n        this.maxX = this.config.tilesWidth;\r\n        this.maxY = this.config.tilesHeight;\r\n        this.loadTiles();\r\n    }\r\n    loadTiles() {\r\n        this.wfcData = new WFCData();\r\n        this.wfcData.tilePieces = {};\r\n        this.wfcData.tileSets = {};\r\n        var tileNames = [\"Castle\", \"Circles\", \"Circuit\", \"FloorPlan\", \"Knots\", \"Rooms\", \"Summer\", \"Sudoku\"];\r\n        for (let tileIndex in tileNames) {\r\n            const tile = tileNames[tileIndex];\r\n            this.wfcData.tilePieces[tile] = require('./metadata/tiles/' + tile + '.json');\r\n            this.wfcData.tileSets[tile] = require('./metadata/sets/' + tile + '.json');\r\n        }\r\n    }\r\n    async initTileData() {\r\n        let pieces = this.wfcData.tilePieces[this.config.tileName];\r\n        let sets = this.wfcData.tileSets[this.config.tileName];\r\n        let currentSet = sets[this.config.set];\r\n        Object.entries(currentSet).forEach((value) => {\r\n            let pieceName = value[0];\r\n            let properties = value[1];\r\n            if (properties.rotations != undefined) {\r\n                pieces.find(x => x.name == pieceName).rotations = properties.rotations;\r\n            }\r\n            if (properties.weight != undefined) {\r\n                pieces.find(x => x.name == pieceName).weight = properties.weight;\r\n            }\r\n            if (properties.edgeblacklist != undefined) {\r\n                pieces.find(x => x.name == pieceName).edgeblacklist = properties.edgeblacklist;\r\n            }\r\n            if (properties.minimum != undefined) {\r\n                pieces.find(x => x.name == pieceName).minimum = properties.minimum;\r\n            }\r\n            if (properties.maximum != undefined) {\r\n                pieces.find(x => x.name == pieceName).maximum = properties.maximum;\r\n            }\r\n        });\r\n        let mappedPieces = pieces.reduce((piecesMap, piece) => {\r\n            if (currentSet[piece.name] == undefined) {\r\n                return piecesMap;\r\n            }\r\n            let pieceSockets = piece.socket;\r\n            piece.socketmatching = {};\r\n            piece.blacklistedNeighbors = {};\r\n            this.tileCounters[piece.name] = { minimum: piece.minimum, maximum: piece.maximum, count: 0 };\r\n            piece.rotations.forEach((rotation) => {\r\n                let socketMatchObject = {};\r\n                let blacklistedNeighbors = {};\r\n                let innerRotation = rotation;\r\n                //TODO: Fix grid fixes and innerRotation\r\n                if (rotation == 2) {\r\n                    innerRotation = 3;\r\n                }\r\n                else if (rotation == 3) {\r\n                    innerRotation = 5;\r\n                }\r\n                Object.keys(Direction).forEach((direction, index) => {\r\n                    if (!isNaN(Number(direction)))\r\n                        return;\r\n                    if (direction == 'grid')\r\n                        return;\r\n                    if (direction == 'grid2')\r\n                        return;\r\n                    let directionsCount = (Object.keys(Direction).length / 2);\r\n                    let directionIndex = Direction[direction];\r\n                    let rotationMoved = (directionIndex - innerRotation + directionsCount) % directionsCount;\r\n                    if ((Direction[rotationMoved] == 'grid' || Direction[rotationMoved] == 'grid2') && innerRotation == 1) {\r\n                        rotationMoved = (rotationMoved - 1 + directionsCount) % directionsCount;\r\n                    }\r\n                    else if ((Direction[rotationMoved] == 'grid' || Direction[rotationMoved] == 'grid2') && innerRotation == 5) {\r\n                        rotationMoved = (rotationMoved + 1 + directionsCount) % directionsCount;\r\n                    }\r\n                    let flipped = directionIndex >= (directionsCount / 2);\r\n                    let sockets = pieceSockets[Direction[rotationMoved]];\r\n                    (Array.isArray(sockets) ? sockets : [sockets]).forEach((socket) => {\r\n                        (socketMatchObject[direction] || (socketMatchObject[direction] = [])).push(flipped ? socket.split(\"\").reverse().join(\"\") : socket);\r\n                    });\r\n                });\r\n                if (this.config.gridSize > 0) {\r\n                    var gridSockets = pieceSockets[Direction[Direction.grid]];\r\n                    var gridSockets2 = pieceSockets[Direction[Direction.grid2]];\r\n                    socketMatchObject[Direction[Direction.grid]] = Array.isArray(gridSockets) ? gridSockets : [gridSockets];\r\n                    socketMatchObject[Direction[Direction.grid2]] = Array.isArray(gridSockets2) ? gridSockets2 : [gridSockets2];\r\n                }\r\n                if (piece.blacklist) {\r\n                    Object.entries(piece.blacklist).forEach((blacklist) => {\r\n                        let blackListDirection = blacklist[0];\r\n                        let blackListValue = blacklist[1];\r\n                        let blackListIndex = Direction[blackListDirection];\r\n                        let directionsCount = (Object.keys(Direction).length / 2);\r\n                        let rotationBlacklistingIndex = (blackListIndex + rotation) % directionsCount; // Fix rotation pointing at innerRotation instead?\r\n                        let rotationBlacklisting = Direction[rotationBlacklistingIndex];\r\n                        Object.entries(blackListValue).forEach((blacklistPiece) => {\r\n                            let blackListPieceName = blacklistPiece[0];\r\n                            let blackListPieceRotations = blacklistPiece[1];\r\n                            blackListPieceRotations.forEach((blackListPieceRotation) => {\r\n                                let blackListPieceNameWithRotation = blackListPieceName + \"_\" + (blackListPieceRotation + rotation) % directionsCount;\r\n                                if (blacklistedNeighbors[rotationBlacklisting] == undefined) {\r\n                                    blacklistedNeighbors[rotationBlacklisting] = [];\r\n                                }\r\n                                blacklistedNeighbors[rotationBlacklisting].push(blackListPieceNameWithRotation);\r\n                            });\r\n                        });\r\n                    });\r\n                }\r\n                piece.blacklistedNeighbors[rotation] = blacklistedNeighbors;\r\n                piece.socketmatching[rotation] = socketMatchObject;\r\n            });\r\n            piecesMap[piece.name] = piece;\r\n            return piecesMap;\r\n        }, {});\r\n        let socketBuckets = {};\r\n        Object.entries(mappedPieces).forEach((mappedPieceValue) => {\r\n            let pieceName = mappedPieceValue[0];\r\n            let piece = mappedPieceValue[1];\r\n            if (piece.socketmatching != undefined) {\r\n                Object.entries(piece.socketmatching).forEach((socketMatchValue) => {\r\n                    let socketDirection = parseInt(socketMatchValue[0]);\r\n                    let socketMatch = socketMatchValue[1];\r\n                    Object.entries(socketMatch).forEach((socket) => {\r\n                        let socketDirectionInner = socket[0];\r\n                        let socketMatchInnerValueArray = socket[1];\r\n                        let socketDirectionInnerIndex = Direction[socketDirectionInner];\r\n                        let directionsCount = (Object.keys(Direction).length / 2);\r\n                        let socketDirectionPolarIndex = (socketDirectionInnerIndex + directionsCount / 2) % directionsCount;\r\n                        let socketDirectionPolar = Direction[socketDirectionPolarIndex];\r\n                        socketMatchInnerValueArray.forEach((socketMatchInnerValue) => {\r\n                            if (socketBuckets[socketMatchInnerValue] == undefined) {\r\n                                let innerObject = {};\r\n                                socketBuckets[socketMatchInnerValue] = innerObject;\r\n                            }\r\n                            if (socketBuckets[socketMatchInnerValue][socketDirectionPolar] == undefined) {\r\n                                socketBuckets[socketMatchInnerValue][socketDirectionPolar] = [];\r\n                            }\r\n                            socketBuckets[socketMatchInnerValue][socketDirectionPolar].push(pieceName + \"_\" + socketDirection);\r\n                        });\r\n                    });\r\n                });\r\n            }\r\n        });\r\n        this.piecesMap = Object.entries(mappedPieces).reduce((piecesMap, piecePair) => {\r\n            let piece = piecePair[1];\r\n            if (currentSet[piece.name] == undefined) {\r\n                return piecesMap;\r\n            }\r\n            if (piece.rotations == undefined) {\r\n                piece.rotations = [0];\r\n            }\r\n            piece.rotations.forEach((rotation) => {\r\n                var _a, _b;\r\n                let innerRotation = rotation;\r\n                if (rotation == 2) {\r\n                    innerRotation = 3;\r\n                }\r\n                else if (rotation == 3) {\r\n                    innerRotation = 5;\r\n                }\r\n                let pieceName = piece.name + \"_\" + rotation;\r\n                let validNeighbors = {\r\n                    top: [],\r\n                    right: [],\r\n                    bottom: [],\r\n                    left: [],\r\n                    grid: [],\r\n                    grid2: []\r\n                };\r\n                if (piece.socketmatching != undefined) {\r\n                    if (piece.socketmatching[rotation] != undefined) {\r\n                        let socketMatch = piece.socketmatching[rotation];\r\n                        Object.entries(socketMatch).forEach((socketPair) => {\r\n                            let socketDirection = socketPair[0];\r\n                            let sockets = socketPair[1];\r\n                            sockets.forEach((socket) => {\r\n                                if (socketBuckets[socket] != undefined && socketBuckets[socket][socketDirection] != undefined) {\r\n                                    let validPiecesForSocket = socketBuckets[socket][socketDirection];\r\n                                    validPiecesForSocket.forEach((validPiece) => {\r\n                                        var _a;\r\n                                        let blackList = (_a = piece.blacklistedNeighbors[rotation][socketDirection]) !== null && _a !== void 0 ? _a : [];\r\n                                        if (!validNeighbors[socketDirection].includes(validPiece) && !blackList.includes(validPiece)) {\r\n                                            validNeighbors[socketDirection].push(validPiece);\r\n                                        }\r\n                                    });\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n                let weight = (_a = piece.weight) !== null && _a !== void 0 ? _a : 1;\r\n                if (Array.isArray(piece.weight)) {\r\n                    weight = (_b = weight[rotation]) !== null && _b !== void 0 ? _b : 1;\r\n                }\r\n                //\r\n                let edgeBlackList = null;\r\n                if (piece.edgeblacklist) {\r\n                    edgeBlackList = piece.edgeblacklist.map((direction) => {\r\n                        let dir = Direction[direction];\r\n                        if (direction == 'grid')\r\n                            return;\r\n                        if (direction == 'grid2')\r\n                            return;\r\n                        let directionsCount = (Object.keys(Direction).length / 2);\r\n                        let rotationMoved = (dir + innerRotation) % directionsCount;\r\n                        if ((Direction[rotationMoved] == 'grid' || Direction[rotationMoved] == 'grid2') && innerRotation == 1) {\r\n                            rotationMoved = (rotationMoved + 1) % directionsCount;\r\n                        }\r\n                        else if ((Direction[rotationMoved] == 'grid' || Direction[rotationMoved] == 'grid2') && innerRotation == 5) {\r\n                            rotationMoved = (rotationMoved - 1) % directionsCount;\r\n                        }\r\n                        return Direction[rotationMoved];\r\n                    });\r\n                }\r\n                piecesMap[pieceName] = new PieceObject(piece.name + \"_\" + rotation, piece.name, rotation, validNeighbors, edgeBlackList, weight, piece.socketmatching[rotation], piece.minimum, piece.maximum);\r\n            });\r\n            return piecesMap;\r\n        }, {});\r\n        return true;\r\n    }\r\n    reset() {\r\n        //this.tileCounters = {};\r\n        let piecesKeys = Object.keys(this.piecesMap);\r\n        let startingTile = {\r\n            validPieces: piecesKeys,\r\n        };\r\n        let useEdgeSocket = false;\r\n        let edgeSockets = {};\r\n        if (this.config.edgeSocket != '') {\r\n            useEdgeSocket = true;\r\n            edgeSockets = {\r\n                \"top\": this.config.edgeSocket,\r\n                \"left\": this.config.edgeSocket.split(\"\").reverse().join(\"\"),\r\n                \"bottom\": this.config.edgeSocket,\r\n                \"right\": this.config.edgeSocket.split(\"\").reverse().join(\"\")\r\n            };\r\n        }\r\n        this.tiles = [];\r\n        for (let x = this.minX; x < this.maxX; x++) {\r\n            if (this.tiles[x] == undefined) {\r\n                this.tiles[x] = this.startingRow(x, startingTile, useEdgeSocket, edgeSockets);\r\n            }\r\n        }\r\n        //console.log('this.tiles', this.tiles);\r\n        Object.entries(this.tileCounters).forEach((value) => {\r\n            let numbers = value[1];\r\n            numbers.count = 0;\r\n        });\r\n    }\r\n    startingCell(x, y, startingTile, useEdgeSocket, edgeSockets) {\r\n        var edges = [];\r\n        if (x == this.minX)\r\n            edges.push('left');\r\n        if (y == this.minY)\r\n            edges.push('top');\r\n        if (x == this.maxX - 1)\r\n            edges.push('right');\r\n        if (y == this.maxY - 1)\r\n            edges.push('bottom');\r\n        if (edges.length > 0) {\r\n            let validPieces = startingTile.validPieces.filter((pieceName) => {\r\n                let piece = this.piecesMap[pieceName];\r\n                let allow = true;\r\n                if (useEdgeSocket) {\r\n                    allow = edges.every(edge => piece.sockets[edge].includes(edgeSockets[edge]));\r\n                }\r\n                if (piece.edgeblacklist) {\r\n                    return !edges.some(v => piece.edgeblacklist.includes(v)) && allow;\r\n                }\r\n                else {\r\n                    return true && allow;\r\n                }\r\n            });\r\n            return {\r\n                position: { x: x, y: y },\r\n                validPieces: validPieces\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                position: { x: x, y: y },\r\n                validPieces: [...startingTile.validPieces]\r\n            };\r\n        }\r\n    }\r\n    startingRow(x, startingTile, useEdgeSocket, edgeSockets) {\r\n        let row = [];\r\n        for (let y = this.minY; y < this.maxY; y++) {\r\n            if (row[y] == undefined) {\r\n                row[y] = this.startingCell(x, y, startingTile, useEdgeSocket, edgeSockets);\r\n            }\r\n        }\r\n        return row;\r\n    }\r\n    expand() {\r\n        this.minX = -this.config.offsetX || 0;\r\n        this.minY = -this.config.offsetY || 0;\r\n        this.maxX = this.config.tilesWidth - (this.config.offsetX || 0);\r\n        this.maxY = this.config.tilesHeight - (this.config.offsetY || 0);\r\n        let piecesKeys = Object.keys(this.piecesMap);\r\n        let startingTile = {\r\n            validPieces: piecesKeys,\r\n        };\r\n        let useEdgeSocket = false;\r\n        let edgeSockets = {};\r\n        if (this.config.edgeSocket != '') {\r\n            useEdgeSocket = true;\r\n            edgeSockets = {\r\n                \"top\": this.config.edgeSocket,\r\n                \"left\": this.config.edgeSocket.split(\"\").reverse().join(\"\"),\r\n                \"bottom\": this.config.edgeSocket,\r\n                \"right\": this.config.edgeSocket.split(\"\").reverse().join(\"\")\r\n            };\r\n        }\r\n        /*\r\n                this.tiles = Array.from({length:this.maxX},\r\n                    (a,x) => {\r\n                        return this.startingRow(x, startingTile, useEdgeSocket, edgeSockets);\r\n                    }\r\n                );*/\r\n        let newCells = [];\r\n        for (let x = this.minX; x < this.maxX; x++) {\r\n            if (this.tiles[x] == undefined) {\r\n                //Entire row is undefined\r\n                this.tiles[x] = this.startingRow(x, startingTile, useEdgeSocket, edgeSockets);\r\n                Object.keys(this.tiles[x]).forEach((yKey) => {\r\n                    let y = parseInt(yKey);\r\n                    newCells.push({\r\n                        x: x,\r\n                        y: y,\r\n                        tile: this.tiles[x][y]\r\n                    });\r\n                });\r\n            }\r\n            else {\r\n                for (let y = this.minY; y < this.maxY; y++) {\r\n                    if (this.tiles[x][y] == undefined) {\r\n                        //Cell is undefined\r\n                        this.tiles[x][y] = this.startingCell(x, y, startingTile, useEdgeSocket, edgeSockets);\r\n                        newCells.push({\r\n                            x: x,\r\n                            y: y,\r\n                            tile: this.tiles[x][y]\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return newCells;\r\n    }\r\n}\r\n","var map = {\n\t\"./Castle.json\": \"./src/metadata/render/Castle.json\",\n\t\"./Circles.json\": \"./src/metadata/render/Circles.json\",\n\t\"./Circuit.json\": \"./src/metadata/render/Circuit.json\",\n\t\"./FloorPlan.json\": \"./src/metadata/render/FloorPlan.json\",\n\t\"./Knots.json\": \"./src/metadata/render/Knots.json\",\n\t\"./Rooms.json\": \"./src/metadata/render/Rooms.json\",\n\t\"./Sudoku.json\": \"./src/metadata/render/Sudoku.json\",\n\t\"./Summer.json\": \"./src/metadata/render/Summer.json\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/metadata/render sync recursive ^\\\\.\\\\/.*\\\\.json$\";","var map = {\n\t\"./Castle.json\": \"./src/metadata/sets/Castle.json\",\n\t\"./Circles.json\": \"./src/metadata/sets/Circles.json\",\n\t\"./Circuit.json\": \"./src/metadata/sets/Circuit.json\",\n\t\"./FloorPlan.json\": \"./src/metadata/sets/FloorPlan.json\",\n\t\"./Knots.json\": \"./src/metadata/sets/Knots.json\",\n\t\"./Rooms.json\": \"./src/metadata/sets/Rooms.json\",\n\t\"./Sudoku.json\": \"./src/metadata/sets/Sudoku.json\",\n\t\"./Summer.json\": \"./src/metadata/sets/Summer.json\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/metadata/sets sync recursive ^\\\\.\\\\/.*\\\\.json$\";","var map = {\n\t\"./Castle.json\": \"./src/metadata/tiles/Castle.json\",\n\t\"./Circles.json\": \"./src/metadata/tiles/Circles.json\",\n\t\"./Circuit.json\": \"./src/metadata/tiles/Circuit.json\",\n\t\"./FloorPlan.json\": \"./src/metadata/tiles/FloorPlan.json\",\n\t\"./Knots.json\": \"./src/metadata/tiles/Knots.json\",\n\t\"./Rooms.json\": \"./src/metadata/tiles/Rooms.json\",\n\t\"./Sudoku.json\": \"./src/metadata/tiles/Sudoku.json\",\n\t\"./Summer.json\": \"./src/metadata/tiles/Summer.json\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/metadata/tiles sync recursive ^\\\\.\\\\/.*\\\\.json$\";","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { WFCTiles } from './WFCTiles';\r\nimport { WFCRender } from \"./WFCRender\";\r\nimport { WFCTextRender } from \"./WFCTextRender\";\r\nimport { WFCRunner } from './WFCRunner';\r\nwindow.getWFCRender = function getWFCRender(canvasId) {\r\n    return new WFCRender(canvasId);\r\n};\r\nwindow.getWFCTextRender = function getWFCTextRender(canvasId) {\r\n    return new WFCTextRender(canvasId);\r\n};\r\nwindow.getWFC = function getWFC() {\r\n    return new WFCTiles();\r\n};\r\nwindow.getWFCRunner = function getWFCRunner(config, wfc) {\r\n    return new WFCRunner(config, wfc);\r\n};\r\n"],"names":[],"sourceRoot":""}